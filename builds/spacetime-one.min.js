/* spencermountain/spacetime 7.4.0 Apache 2.0 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.spacetime = factory());
})(this, (function () { 'use strict';

  //find the implicit iana code for this machine.
  //safely query the Intl object
  //based on - https://bitbucket.org/pellepim/jstimezonedetect/src

  //this Intl object is not supported often, yet
  const safeIntl = () => {
    if (typeof Intl === 'undefined' || typeof Intl.DateTimeFormat === 'undefined') {
      return null
    }
    let format = Intl.DateTimeFormat();
    if (typeof format === 'undefined' || typeof format.resolvedOptions === 'undefined') {
      return null
    }
    let timezone = format.resolvedOptions().timeZone;
    if (!timezone) {
      return null
    }
    return timezone
  };

  //do it once per computer
  var guessTz = safeIntl;

  var config = {

    am: 'am',
    pm: 'pm',

    //https://www.timeanddate.com/calendar/aboutseasons.html
    seasons: {
      north: [
        ['spring', 2, 1],//from March 1 to May 31
        ['summer', 5, 1], //from June 1 to August 31
        ['fall', 8, 1], //from September 1 to November 30
        ['winter', 11, 1] //from December 1 to February 28 (or feb 29)
      ],
      south: [
        ['fall', 2, 1],
        ['winter', 5, 1],
        ['spring', 8, 1],
        ['summer', 11, 1] //dec 1
      ]
    },

    // order is from javascript Date
    days: {
      shortForm: ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'],
      longForm: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday']
    },

    //default is Monday
    weekStart: 1,

    quarters: [
      [0, 1], //Q1 - Jan 1
      [3, 1], //Q2 - Apr 1
      [6, 1], //Q3 - July 1
      [9, 1] //Q4 - Oct 1
    ],

    months: {
      shortForm: ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'],
      longForm: ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december']
    },

    useTitleCase: true, // automatically in .format()

    // local timezone
    // if Intl.DateTimeFormat is not supported - fallback to UTC
    fallbackTz: guessTz() || 'Etc/Utc',

    // <15% of the world lives in the Southern Hemisphere
    fallbackHemisphere: 'n',

    // assumed year in 'march 12th'
    fallbackYear: 2023,

    // assume the british interpretation of 02/02/2018, etc
    preferDMY: false,

    // this should be the only call to js Date
    now: () => new Date().getTime(),

    // if the given epoch is really small, it's very likely in seconds and not milliseconds
    // - all years < 2023 map to the first 20 days of Jan 1970 (1.7 billion)
    // - all years < 2049 map to January 1970 (2.5 billion)
    // anything below this number is likely (but not necessarily) a mistaken input.
    // set as null to allow setting epoch inputs for Jan 1970
    minimumEpoch: 2500000000 // 2.5 billion

  };

  //https://www.timeanddate.com/date/leapyear.html
  const isLeapYear = function (year) {
    // no leap years in bc
    // if (year < 0) {
    //   return false
    // }
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)
  };
  var isLeap = isLeapYear;

  const SECOND = 1000;
  const MINUTE = 60 * SECOND;
  const HOUR = 60 * MINUTE;
  const DAY = 24 * HOUR;

  const YEAR = 365 * DAY;
  const LEAPYEAR = YEAR + DAY;

  var pckd = `Africa
	Abidjan,0,GMT
	Accra,0,GMT
	Addis_Ababa,3,EAT
	Algiers,1,CET|CEST
	Asmara,3,EAT
	Bamako,0,GMT
	Bangui,1,WAT
	Banjul,0,GMT
	Bissau,0,GMT
	Blantyre,2,CAT,s
	Brazzaville,1,WAT
	Bujumbura,2,CAT,s
	Cairo,2,EET|EEST
	Casablanca,0,WET|WEST,saha
	Ceuta,1,CET|CEST,eu2
	Conakry,0,GMT
	Dakar,0,GMT
	Dar_Es_Salaam,3,EAT
	Djibouti,3,EAT
	Douala,1,WAT
	El_Aaiun,0,WET|WEST,saha
	Freetown,0,GMT
	Gaborone,2,CAT,s
	Harare,2,CAT,s
	Johannesburg,2,SAST,s
	Juba,3,CAT
	Kampala,3,EAT
	Khartoum,2,CAT
	Kigali,2,CAT,s
	Kinshasa,1,WAT
	Lagos,1,WAT
	Libreville,1,WAT
	Lome,0,GMT
	Luanda,1,WAT
	Lubumbashi,2,CAT,s
	Lusaka,2,CAT,s
	Malabo,1,WAT
	Maputo,2,CAT,s
	Maseru,2,SAST,s
	Mbabane,2,SAST,s
	Mogadishu,3,EAT
	Monrovia,0,GMT
	Nairobi,3,EAT
	Ndjamena,1,WAT
	Niamey,1,WAT
	Nouakchott,0,GMT
	Ouagadougou,0,GMT
	Porto-novo,1,WAT
	Sao_Tome,0,GMT
	Tripoli,2,EET|EEST
	Tunis,1,CET|CEST
	Windhoek,1,CAT,s
America
	Adak,-10,HST|HDT,usa
	Anchorage,-9,AKST|AKDT,usa
	Anguilla,-4,AST|ADT
	Antigua,-4,AST|ADT
	Araguaina,-3,BRT
	Argentina,-3,ART,s
	Argentina/Buenos_Aires,-3,ART,s
	Argentina/Catamarca,-3,ART,s
	Argentina/Cordoba,-3,ART,s
	Argentina/La_Rioja,-3,ART,s
	Argentina/Mendoza,-3,ART,s
	Argentina/Rio_Gallegos,-3,ART,s
	Argentina/Salta,-3,ART,s
	Argentina/San_Juan,-3,ART,s
	Argentina/San_Luis,-3,ART,s
	Argentina/Tucuman,-3,ART,s
	Argentina/Ushuaia,-3,ART,s
	Aruba,-4,AST|ADT
	Asuncion,-4,PYT|PYST,par,s
	Atikokan,-5,EST|EDT
	Bahia,-3,BRT
	Bahia_Banderas,-6,CST|CDT,mex
	Barbados,-4,AST|ADT
	Belem,-3,BRT
	Belize,-6,CST|CDT
	Blanc-sablon,-4,AST|ADT
	Boa_Vista,-4,AMT
	Bogota,-5,COT
	Boise,-7,MST|MDT,usa
	Buenos_Aires,-3,ART,s
	Cambridge_Bay,-7,MST|MDT,usa
	Campo_Grande,-4,AMT,s
	Cancun,-5,EST|EDT
	Caracas,-4,VET
	Catamarca,-3,ART,s
	Cayenne,-3,GFT
	Cayman,-5,EST|EDT
	Chicago,-6,CST|CDT,usa
	Chihuahua,-7,HNPMX|HEPMX,mex
	Cordoba,-3,ART,s
	Costa_Rica,-6,CST|CDT
	Creston,-7,MST|MDT
	Cuiaba,-4,AMT,s
	Curacao,-4,AST|ADT
	Danmarkshavn,0,GMT
	Dawson,-7,MST|MDT
	Dawson_Creek,-7,MST|MDT
	Denver,-7,MST|MDT,usa
	Detroit,-5,EST|EDT,usa
	Dominica,-4,AST|ADT
	Edmonton,-7,MST|MDT,usa
	Eirunepe,-5,ACT
	El_Salvador,-6,CST|CDT
	Ensenada,-8,PST|PDT,usa
	Fort_Nelson,-7,MST|MDT
	Fort_wayne,-5,EST|EDT,usa
	Fortaleza,-3,BRT,s
	Glace_Bay,-4,AST|ADT,usa
	Godthab,-3,WGT|WGST,green
	Goose_Bay,-4,AST|ADT,usa
	Grand_Turk,-5,EST|EDT,usa
	Grenada,-4,AST|ADT
	Guadeloupe,-4,AST|ADT
	Guatemala,-6,CST|CDT
	Guayaquil,-5,ECT
	Guyana,-4,GYT
	Halifax,-4,AST|ADT,usa
	Havana,-5,HNCU|HECU,cuba
	Hermosillo,-7,HNPMX|HEPMX
	Indiana,-5,EST|EDT,usa
	Indiana/Indianapolis,-5,EST|EDT,usa
	Indiana/Knox,-6,CST|CDT,usa
	Indiana/Marengo,-5,EST|EDT,usa
	Indiana/Petersburg,-5,EST|EDT,usa
	Indiana/Tell_City,-6,CST|CDT,usa
	Indiana/Vevay,-5,EST|EDT,usa
	Indiana/Vincennes,-5,EST|EDT,usa
	Indiana/Winamac,-5,EST|EDT,usa
	Indianapolis,-5,EST|EDT,usa
	Inuvik,-7,MST|MDT,usa
	Iqaluit,-5,EST|EDT,usa
	Jamaica,-5,EST|EDT
	Jujuy,-3,ART,s
	Juneau,-9,AKST|AKDT,usa
	Kentucky,-5,EST|EDT,usa
	Kentucky/Louisville,-5,EST|EDT,usa
	Kentucky/Petersburg,-5,EST|EDT,usa
	Knox_in,-5,EST|EDT,usa
	Kralendijk,-4,AST|ADT
	La_Paz,-4,BOT,s
	Lima,-5,PET,s
	Los_Angeles,-8,PST|PDT,usa
	Louisville,-5,EST|EDT,usa
	Lower_Princes,-4,AST|ADT
	Maceio,-3,BRT
	Managua,-6,CST|CDT
	Manaus,-4,AMT,s
	Marigot,-4,AST|ADT
	Martinique,-4,AST|ADT
	Matamoros,-6,CST|CDT,usa
	Mazatlan,-7,HNPMX|HEPMX,mex
	Mendoza,-3,ART,s
	Menominee,-6,CST|CDT,usa
	Merida,-6,CST|CDT,mex
	Metlakatla,-9,AKST|AKDT,usa
	Mexico_City,-6,CST|CDT,mex
	Miquelon,-3,HNPM|HEPM,usa
	Moncton,-4,AST|ADT,usa
	Monterrey,-6,CST|CDT,mex
	Montevideo,-3,UYT,s
	Montreal,-5,EST|EDT,usa
	Montserrat,-4,AST|ADT
	Nassau,-5,EST|EDT,usa
	New_York,-5,EST|EDT,usa
	Nipigon,-5,EST|EDT,usa
	Nome,-9,AKST|AKDT,usa
	Noronha,-2,FNT
	North_Dakota/Beulah,-6,CST|CDT,usa
	North_Dakota/Center,-6,CST|CDT,usa
	North_Dakota/New_Salem,-6,CST|CDT,usa
	North_dakota,-7,MST|MDT,usa
	Nuuk,-3,WGT|WGST,green
	Ojinaga,-7,MST|MDT,usa
	Panama,-5,EST|EDT
	Pangnirtung,-5,EST|EDT,usa
	Paramaribo,-3,SRT
	Phoenix,-7,MST|MDT
	Port-au-prince,-5,EST|EDT,usa
	Port_Of_Spain,-4,AST|ADT
	Porto_Velho,-4,AMT
	Porto_acre,-5,ACT,s
	Puerto_Rico,-4,AST|ADT
	Punta_Arenas,-3,CLT|CLST,s
	Rainy_River,-6,CST|CDT,usa
	Rankin_Inlet,-6,CST|CDT,usa
	Recife,-3,BRT
	Regina,-6,CST|CDT
	Resolute,-6,CST|CDT,usa
	Rio_Branco,-5,ACT,s
	Rosario,-3,ART,s
	Santa_isabel,-8,PST|PDT,usa
	Santarem,-3,BRT
	Santiago,-4,CLT|CLST,chile,s
	Santo_Domingo,-4,AST|ADT
	Sao_Paulo,-3,BRT,s
	Scoresbysund,-1,HNEG|HEEG,eu0
	Shiprock,-7,MST|MDT,usa
	Sitka,-9,AKST|AKDT,usa
	St_Barthelemy,-4,AST|ADT
	St_Johns,-3.5,HNTN|HETN,usa
	St_Kitts,-4,AST|ADT
	St_Lucia,-4,AST|ADT
	St_Thomas,-4,AST|ADT
	St_Vincent,-4,AST|ADT
	Swift_Current,-6,CST|CDT
	Tegucigalpa,-6,CST|CDT
	Thule,-4,AST|ADT,usa
	Thunder_Bay,-5,EST|EDT,usa
	Tijuana,-8,PST|PDT,usa
	Toronto,-5,EST|EDT,usa
	Tortola,-4,AST|ADT
	Vancouver,-8,PST|PDT,usa
	Virgin,-4,AST|ADT
	Whitehorse,-7,MST|MDT
	Winnipeg,-6,CST|CDT,usa
	Yakutat,-9,AKST|AKDT,usa
	Yellowknife,-7,MST|MDT,usa
Antarctica
	Casey,8,CAST|CAST,ant,s
	Davis,7,DAVT,s
	Dumontdurville,10,PGT,s
	Macquarie,11,AEST|AEDT,aus,s
	Mawson,5,MAWT,s
	Mcmurdo,12,NZST|NZDT,nz,s
	Palmer,-3,ART,s
	Rothera,-3,ART,s
	South_pole,12,NZST|NZDT,nz,s
	Syowa,3,AST
	Troll,2,GMT,troll,s
	Vostok,6,MSK+4,s
Arctic
	Longyearbyen,1,CET|CEST,eu2
Asia
	Aden,3,AST
	Almaty,6,ALMT
	Amman,2,EET|EEST,jord
	Anadyr,12,ANAT
	Aqtau,5,ALMT
	Aqtobe,5,ALMT
	Ashgabat,5,TMT
	Ashkhabad,5,TMT
	Atyrau,5,ALMT
	Baghdad,3,AST
	Bahrain,3,AST
	Baku,4,AZT
	Bangkok,7,ICT
	Barnaul,7,KRAT
	Beirut,2,EET|EEST,leb
	Bishkek,6,KGT
	Brunei,8,BNT
	Calcutta,5.5,IST
	Chita,9,YAKT
	Choibalsan,8,ULAT
	Chongqing,8,CST
	Chungking,8,CST
	Colombo,5.5,IST
	Dacca,6,BST
	Damascus,2,EET|EEST,syr
	Dhaka,6,BST
	Dili,9,TLT,s
	Dubai,4,GST
	Dushanbe,5,TJT
	Famagusta,2,EET|EEST,eu3
	Gaza,2,EET|EEST,pal
	Harbin,8,CST
	Hebron,2,EET|EEST,pal
	Ho_Chi_Minh,7,ICT
	Hong_Kong,8,HKT
	Hovd,7,HOVT
	Irkutsk,8,IRKT
	Istanbul,3,TRT
	Jakarta,7,WIB,s
	Jayapura,9,WIT,s
	Jerusalem,2,IST|IDT,isr
	Kabul,4.5,AFT
	Kamchatka,12,PETT
	Karachi,5,PKT
	Kashgar,8,CST
	Kathmandu,5.75,NPT
	Katmandu,5.75,NPT
	Khandyga,9,YAKT
	Kolkata,5.5,IST
	Krasnoyarsk,7,KRAT
	Kuala_Lumpur,8,MYT,s
	Kuching,8,MYT
	Kuwait,3,AST
	Macao,8,CST
	Macau,8,CST
	Magadan,11,MAGT
	Makassar,8,WITA,s
	Manila,8,PHST
	Muscat,4,GST
	Nicosia,2,EET|EEST,eu3
	Novokuznetsk,7,KRAT
	Novosibirsk,7,NOVT
	Omsk,6,OMST
	Oral,5,ALMT
	Phnom_Penh,7,ICT
	Pontianak,7,WIB
	Pyongyang,9,KST
	Qatar,3,AST
	Qostanay,6,ALMT
	Qyzylorda,6,ALMT
	Rangoon,6.5,MMT
	Riyadh,3,AST
	Saigon,7,ICT
	Sakhalin,11,SAKT
	Samarkand,5,UZT
	Seoul,9,KST
	Shanghai,8,CST
	Singapore,8,SGT,s
	Srednekolymsk,12,SRET
	Taipei,8,CST
	Tashkent,5,UZT
	Tbilisi,4,GET
	Tehran,3.5,IRST|IRDT,iran
	Tel_aviv,2,IST|IDT,isr
	Thimbu,6,BT
	Thimphu,6,BT
	Tokyo,9,JST
	Tomsk,7,OMST
	Ujung_pandang,8,WITA,s
	Ulaanbaatar,8,ULAT
	Ulan_bator,8,ULAT
	Urumqi,8,CST
	Ust-nera,10,VLAT
	Vientiane,7,ICT
	Vladivostok,10,VLAT
	Yakutsk,10,YAKT
	Yangon,6.5,MMT
	Yekaterinburg,5,YEKT
	Yerevan,4,AMT
Atlantic
	Azores,-1,AZOT|AZOST,eu0
	Bermuda,-4,AST|ADT,usa
	Canary,0,WET|WEST,eu1
	Cape_Verde,-1,CVT
	Faeroe,0,WET|WEST,eu1
	Faroe,0,WET|WEST,eu1
	Jan_mayen,1,CET|CEST,eu2
	Madeira,0,WET|WEST,eu1
	Reykjavik,0,GMT
	South_Georgia,-2,GST
	St_Helena,0,GMT
	Stanley,-3,FKST,s
Australia
	Act,10,AEST|AEDT,aus,s
	Adelaide,9.5,ACST|ACDT,aus,s
	Brisbane,10,AEST,s
	Broken_Hill,9.5,ACST|ACDT,aus,s
	Canberra,10,AEST|AEDT,aus,s
	Currie,10,AEST|AEDT,aus,s
	Darwin,9.5,ACST,s
	Eucla,8.75,ACWST,s
	Hobart,10,AEST|AEDT,aus,s
	Lhi,10.5,LHST|LHDT,lhow,s
	Lindeman,10,AEST,s
	Lord_Howe,10.5,LHST|LHDT,lhow,s
	Melbourne,10,AEST|AEDT,aus,s
	North,9.5,ACST,s
	Nsw,10,AEST|AEDT,aus,s
	Perth,8,AWST,s
	Queensland,10,AEST,s
	South,9.5,ACST|ACDT,aus,s
	Sydney,10,AEST|AEDT,aus,s
	Tasmania,10,AEST|AEDT,aus,s
	Victoria,10,AEST|AEDT,aus,s
	West,8,AWST,s
	Yancowinna,9.5,ACST|ACDT,aus,s
Brazil
	Acre,-5,ACT,s
	Denoronha,-2,FNT
	East,-3,BRT,s
	West,-4,AMT,s
Canada
	Atlantic,-4,AST|ADT,usa
	Central,-6,CST|CDT,usa
	East-saskatchewan,-6,CST|CDT
	Eastern,-5,EST|EDT,usa
	Mountain,-7,MST|MDT,usa
	Newfoundland,-3.5,HNTN|HETN,usa
	Pacific,-8,PST|PDT,usa
	Saskatchewan,-6,CST|CDT
	Yukon,-7,MST|MDT
Chile
	Continental,-4,CLT|CLST,chile,s
	Easterisland,-6,EAST|EASST,east,s
Cuba
	,-5,HNCU|HECU,cuba
Egypt
	,2,EET|EEST
Eire
	,0,GMT|IST,eu1
Etc
	GMT,0,GMT
	Greenwich,0,GMT
	Uct,0,UTC
	Universal,0,UTC
	Unknown,0,UTC
	Utc,0,UTC
	Zulu,0,UTC
Europe
	Amsterdam,1,CET|CEST,eu2
	Andorra,1,CET|CEST,eu2
	Astrakhan,4,MSK
	Athens,2,EET|EEST,eu3
	Belfast,0,GMT|BST,eu1
	Belgrade,1,CET|CEST,eu2
	Berlin,1,CET|CEST,eu2
	Bratislava,1,CET|CEST,eu2
	Brussels,1,CET|CEST,eu2
	Bucharest,2,EET|EEST,eu3
	Budapest,1,CET|CEST,eu2
	Busingen,1,CET|CEST,eu2
	Chisinau,2,EET|EEST,eu2
	Copenhagen,1,CET|CEST,eu2
	Dublin,0,GMT|IST,eu1
	Gibraltar,1,CET|CEST,eu2
	Guernsey,0,GMT|BST,eu1
	Helsinki,2,EET|EEST,eu3
	Isle_Of_Man,0,GMT|BST,eu1
	Istanbul,3,TRT
	Jersey,0,GMT|BST,eu1
	Kaliningrad,2,EET|EEST
	Kiev,2,EET|EEST,eu3
	Kirov,3,MSK
	Kyiv,2,EET|EEST,eu3
	Lisbon,0,WET|WEST,eu1
	Ljubljana,1,CET|CEST,eu2
	London,0,GMT|BST,eu1
	Luxembourg,1,CET|CEST,eu2
	Madrid,1,CET|CEST,eu2
	Malta,1,CET|CEST,eu2
	Mariehamn,2,EET|EEST,eu3
	Minsk,3,MSK
	Monaco,1,CET|CEST,eu2
	Moscow,3,MSK
	Nicosia,2,EET|EEST,eu3
	Oslo,1,CET|CEST,eu2
	Paris,1,CET|CEST,eu2
	Podgorica,1,CET|CEST,eu2
	Prague,1,CET|CEST,eu2
	Riga,2,EET|EEST,eu3
	Rome,1,CET|CEST,eu2
	Samara,4,SAMT
	San_Marino,1,CET|CEST,eu2
	Sarajevo,1,CET|CEST,eu2
	Saratov,4,SAMT
	Simferopol,2,EET|EEST,eu3
	Skopje,1,CET|CEST,eu2
	Sofia,2,EET|EEST,eu3
	Stockholm,1,CET|CEST,eu2
	Tallinn,2,EET|EEST,eu3
	Tirane,1,CET|CEST,eu2
	Tiraspol,2,EET|EEST,eu2
	Ulyanovsk,4,MSK
	Uzhgorod,2,EET|EEST,eu3
	Vaduz,1,CET|CEST,eu2
	Vatican,1,CET|CEST,eu2
	Vienna,1,CET|CEST,eu2
	Vilnius,2,EET|EEST,eu3
	Volgograd,4,MSK
	Warsaw,1,CET|CEST,eu2
	Zagreb,1,CET|CEST,eu2
	Zaporozhye,2,EET|EEST,eu3
	Zurich,1,CET|CEST,eu2
GB
	,0,GMT|BST,eu1
Gb-eire
	,0,GMT|BST,eu1
Gmt+0
	,0,GMT
Gmt-0
	,0,GMT
Gmt0
	,0,GMT
Greenwich
	,0,GMT
Hongkong
	,8,HKT
Iceland
	,0,GMT
Indian
	Antananarivo,3,EAT
	Chagos,6,IOT
	Christmas,7,CXT,s
	Cocos,6.5,CCT
	Comoro,3,EAT
	Kerguelen,5,TFT,s
	Mahe,4,SCT
	Maldives,5,MVT
	Mauritius,4,MUT
	Mayotte,3,EAT
	Reunion,4,RET,s
Iran
	,3.5,IRST|IRDT,iran
Israel
	,2,IST|IDT,isr
Jamaica
	,-5,EST|EDT
Japan
	,9,JST
Kwajalein
	,12,MHT
Libya
	,2,EET|EEST
Mexico
	Bajanorte,-8,PST|PDT,usa
	Bajasur,-7,HNPMX|HEPMX,mex
	General,-6,CST|CDT,mex
Navajo
	,-7,MST|MDT,usa
Nz
	,12,NZST|NZDT,nz,s
Nz-chat
	,12.75,CHAST|CHADT,chat,s
Pacific
	Apia,13,WST|WST,s
	Auckland,12,NZST|NZDT,nz,s
	Bougainville,11,PGT,s
	Chatham,12.75,CHAST|CHADT,chat,s
	Chuuk,10,CHUT
	Easter,-6,EAST|EASST,east,s
	Efate,11,VUT
	Fakaofo,13,TKT
	Fiji,12,FJT|FJT,fiji,s
	Funafuti,12,TVT
	Galapagos,-6,COT
	Gambier,-9,GAMT
	Guadalcanal,11,SBT
	Guam,10,ChST
	Honolulu,-10,HAST|HADT
	Johnston,-10,HAST|HADT
	Kanton,13,PHOT
	Kiritimati,14,LINT
	Kosrae,11,KOST
	Kwajalein,12,MHT
	Majuro,12,MHT
	Marquesas,-9.5,MART
	Midway,-11,SST
	Nauru,12,NRT
	Niue,-11,NUT
	Norfolk,10.5,NFT|NFDT,aus
	Noumea,11,NCT
	Pago_Pago,-11,SST
	Palau,9,PWT
	Pitcairn,-8,PST
	Pohnpei,11,PONT
	Ponape,11,PONT
	Port_Moresby,10,PGT,s
	Rarotonga,-10,CKT
	Saipan,10,ChST
	Samoa,-11,SST
	Tahiti,-10,TAHT
	Tarawa,12,GILT
	Tongatapu,13,TOT,s
	Truk,10,CHUT
	Wake,12,WAKT
	Wallis,12,WFT
	Yap,10,CHUT
Poland
	,1,CET|CEST,eu2
Portugal
	,0,WET|WEST,eu1
Prc
	,8,CST
Roc
	,8,CST
Rok
	,9,KST
Singapore
	,8,SGT,s
Turkey
	,3,TRT
UTC
	,0,UTC
	Unknown,0,UTC
Uct
	,0,UTC
Universal
	,0,UTC
Us
	Alaska,-9,AKST|AKDT,usa
	Aleutian,-10,HST|HDT,usa
	Arizona,-7,MST|MDT
	Central,-6,CST|CDT,usa
	East-indiana,-5,EST|EDT,usa
	Eastern,-5,EST|EDT,usa
	Hawaii,-10,HAST|HADT
	Indiana-starke,-5,EST|EDT,usa
	Michigan,-5,EST|EDT,usa
	Mountain,-7,MST|MDT,usa
	Pacific,-8,PST|PDT,usa
	Pacific-new,-8,PST|PDT,usa
	Samoa,-11,SST
W-su
	,3,MSK
Zulu
	,0,UTC
america
	argentina/buenos_aires,-3,ART,s
	argentina/catamarca,-3,ART,s
	argentina/comodrivadavia,-3,ART,s
	argentina/cordoba,-3,ART,s
	argentina/jujuy,-3,ART,s
	argentina/mendoza,-3,ART,s
	argentina/rosario,-3,ART,s
`;

  let zones$1 = {};
  let area = null;
  // unpack compressed iana file
  pckd.split('\n').forEach(line => {
    if (!/^\t/.test(line)) {
      area = line.trim();
      return
    }
    let [name, offset, shrt, dst, hem] = line.split(/,/);
    let iana = `${area}/${name.trim()}`;
    shrt = shrt.split(/\|/);
    offset = Number(offset);
    zones$1[iana] = { offset, shrt };
    if (dst) {
      zones$1[iana].dst = dst;
    }
    zones$1[iana].hem = hem ? hem : 'n';
  });

  //add etc/gmt+n
  for (let i = -14; i <= 14; i += 0.5) {
    let num = i;
    if (num > 0) {
      num = '+' + num;
    }
    // Etc/GMT-5
    let name = 'Etc/GMT' + num;
    zones$1[name] = {
      offset: i * -1, //they're negative!
      hem: 'n' //(sorry)
    };
    let alias = 'UTC/GMT' + num; //this one too, why not.
    zones$1[alias] = zones$1[name];
  }
  // this appear sometimes
  zones$1['Etc/GMT+0'] = zones$1['Etc/GMT'];
  zones$1['Etc/GMT-0'] = zones$1['Etc/GMT'];
  // add aliases
  // Object.keys(aliases).forEach(k => {
  //   zones[k] = zones[aliases[k]]
  //   if (!zones[k]) {
  //     console.log(k)
  //   }
  // })
  var zones$2 = zones$1;

  const MAXOFFSET = -DAY * 2;
  const memo$1 = {};

  const utcStart = function (year) {
    // try and compute this only once
    if (memo$1.hasOwnProperty(year)) {
      return memo$1[year]
    }
    let epoch = 0;
    // count up from 1970
    if (year > 1970) {
      for (let y = 1970; y < year; y += 1) {
        if (isLeap(y)) {
          epoch += LEAPYEAR;
        } else {
          epoch += YEAR;
        }
        memo$1[y + 1] = epoch;
      }
    } else {
      // count down from 1970
      let y = 1970;
      while (y > year) {
        y -= 1;
        if (isLeap(y)) {
          epoch -= LEAPYEAR;
        } else {
          epoch -= YEAR;
        }
        memo$1[y] = epoch;
      }
    }
    return epoch
  };

  const januaryOffset = function (tz) {
    // apply timezone offset to it
    if (tz && zones$2.hasOwnProperty(tz) && zones$2[tz]) {
      let zone = zones$2[tz];
      let offset = zone.offset || 0;
      // are we in DST on Jan 1st?
      // all 16 southern hemisphere zones w/ DST
      if (zone.hem === 's' && zone.dst) {
        offset += zone.change || 1;
      }
      return offset * HOUR
    }
    return 0
  };

  // get UTC epoch for jan 1
  const getStart = function (year, tz) {
    let epoch = utcStart(year);
    epoch -= januaryOffset(tz);
    return epoch
  };

  // from a random epoch, get it's Jan 1st alignment
  const getYear = function (target, tz) {
    let epoch = 0;
    // apply timezone offset to it
    epoch -= januaryOffset(tz);
    let year = 1970;
    // count upwards from 1970
    if (target > MAXOFFSET) {
      while (epoch <= target) {
        let size = YEAR;
        if (isLeap(year)) {
          size = LEAPYEAR;
        }
        let tmp = epoch + size;
        if (tmp > target) {
          break
        }
        epoch = tmp;
        year += 1;
      }
    } else {
      // count downwards from 1970
      while (epoch > target) {
        let size = YEAR;
        if (isLeap(year)) {
          size = LEAPYEAR;
        }
        epoch -= size;
        year -= 1;
      }
    }
    return { start: epoch, year }
  };

  // these are the folk heuristics that timezones use to set their dst change dates
  // for example, the US changes:
  // the second Sunday of March -> first Sunday of November
  // http://www.webexhibits.org/daylightsaving/g.html
  let changes = {
    usa: '2nd-sun-mar-2h|1st-sun-nov-2h',// (From 1987 to 2006)
    // mexico
    mex: '1st-sun-apr-2h|last-sun-oct-2h',
    // European Union zone
    eu0: 'last-sun-mar-0h|last-sun-oct-1h',
    eu1: 'last-sun-mar-1h|last-sun-oct-2h',
    eu2: 'last-sun-mar-2h|last-sun-oct-3h',
    eu3: 'last-sun-mar-3h|last-sun-oct-4h',
    //greenland
    green: 'last-sat-mar-22h|last-sat-oct-23h',
    // australia
    aus: '1st-sun-apr-1h|1st-sun-oct-2h',
    //lord howe australia
    lhow: '1st-sun-apr-0.5h|1st-sun-oct-2h',
    // new zealand
    chat: '1st-sun-apr-2h|last-sun-sep-2h', //technically 3:45h -> 2:45h
    // new Zealand, antarctica 
    nz: '1st-sun-apr-1h|last-sun-sep-2h',
    // casey - antarctica
    ant: '2nd-sun-mar-0h|1st-sun-oct-0h',
    // troll - antarctica
    troll: 'last-sun-mar-2h|last-sun-oct-3h',
    //jordan
    jord: 'last-fri-feb-0h|last-fri-oct-1h',
    // lebanon
    leb: 'last-sun-mar-0h|last-sun-oct-0h',
    // syria
    syr: 'last-fri-mar-0h|last-fri-oct-0h',
    //israel
    // Start: Last Friday before April 2 -> The Sunday between Rosh Hashana and Yom Kippur
    isr: 'last-fri-mar-2h|last-sun-oct-2h',
    //palestine
    pal: 'last-sun-mar-0h|last-fri-oct-1h',
    // el aaiun
    //this one seems to be on arabic calendar?
    saha: 'last-sun-mar-3h|1st-sun-may-2h',
    // paraguay
    par: 'last-sat-mar-22h|1st-sun-oct-0h',
    //cuba
    cuba: '2nd-sun-mar-0h|1st-sun-nov-1h',
    //chile
    chile: '1st-sat-apr-22h|1st-sun-sep-0h',
    //easter island
    east: '1st-sat-apr-20h|1st-sat-sep-22h',
    //fiji
    fiji: '3rd-sun-jan-3h|2nd-sun-nov-2h',
    // iran
    iran: '4th-mon-march-0h|3rd-fri-sep-0h',//arabic calendar?

  };

  const months$1 = 'jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec'.split('|');
  const days$1 = 'sun|mon|tue|wed|thu|fri|sat'.split('|');

  const parse$2 = function (str) {
    let [num, day, month, hour] = str.split(/-/g);
    hour = hour.replace(/h$/, '');
    hour = Number(hour);

    if (num !== 'last') {
      num = num.replace(/(st|nd|rd|th)$/, '');
      num = Number(num) || num;
    }
    //convert to numbers
    month = months$1.indexOf(month) + 1;
    day = days$1.indexOf(day);
    return {
      num, day, month, hour
    }
  };

  Object.keys(changes).forEach(k => {
    let str = changes[k];
    let [start, end] = str.split(/\|/);
    changes[k] = {
      start: parse$2(start),
      end: parse$2(end),
    };
  });

  var patterns = changes;

  var zones = {
    "Africa/Abidjan": {
      "offset": 0,
      "hem": "n",
      "shrt": "GMT"
    },
    "Africa/Algiers": {
      "offset": 1,
      "hem": "n",
      "shrt": "CET|CEST"
    },
    "Africa/Bissau": {
      "offset": 0,
      "hem": "n",
      "shrt": "GMT"
    },
    "Africa/Cairo": {
      "offset": 2,
      "hem": "n",
      "shrt": "EET|EEST"
    },
    "Africa/Casablanca": {
      "offset": 0,
      "hem": "n",
      "dst": "saha",
      "shrt": "WET|WEST"
    },
    "Africa/Ceuta": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Africa/El_Aaiun": {
      "offset": 0,
      "hem": "n",
      "dst": "saha",
      "shrt": "WET|WEST"
    },
    "Africa/Johannesburg": {
      "offset": 2,
      "hem": "s",
      "shrt": "SAST"
    },
    "Africa/Juba": {
      "offset": 3,
      "hem": "n",
      "shrt": "CAT"
    },
    "Africa/Khartoum": {
      "offset": 2,
      "hem": "n",
      "shrt": "CAT"
    },
    "Africa/Lagos": {
      "offset": 1,
      "hem": "n",
      "shrt": "WAT"
    },
    "Africa/Maputo": {
      "offset": 2,
      "hem": "s",
      "shrt": "CAT"
    },
    "Africa/Monrovia": {
      "offset": 0,
      "hem": "n",
      "shrt": "GMT"
    },
    "Africa/Nairobi": {
      "offset": 3,
      "hem": "n",
      "shrt": "EAT"
    },
    "Africa/Ndjamena": {
      "offset": 1,
      "hem": "n",
      "shrt": "WAT"
    },
    "Africa/Sao_Tome": {
      "offset": 0,
      "hem": "n",
      "shrt": "GMT"
    },
    "Africa/Tripoli": {
      "offset": 2,
      "hem": "n",
      "shrt": "EET|EEST"
    },
    "Africa/Tunis": {
      "offset": 1,
      "hem": "n",
      "shrt": "CET|CEST"
    },
    "Africa/Windhoek": {
      "offset": 1,
      "hem": "s",
      "shrt": "CAT"
    },
    "America/Adak": {
      "offset": -10,
      "hem": "n",
      "dst": "usa",
      "shrt": "HST|HDT"
    },
    "America/Anchorage": {
      "offset": -9,
      "hem": "n",
      "dst": "usa",
      "shrt": "AKST|AKDT"
    },
    "America/Araguaina": {
      "offset": -3,
      "hem": "n",
      "shrt": "BRT"
    },
    "America/Asuncion": {
      "offset": -4,
      "hem": "s",
      "dst": "par",
      "shrt": "PYT|PYST"
    },
    "America/Bahia": {
      "offset": -3,
      "hem": "n",
      "shrt": "BRT"
    },
    "America/Bahia_Banderas": {
      "offset": -6,
      "hem": "n",
      "dst": "mex",
      "shrt": "CST|CDT"
    },
    "America/Barbados": {
      "offset": -4,
      "hem": "n",
      "shrt": "AST|ADT"
    },
    "America/Belem": {
      "offset": -3,
      "hem": "n",
      "shrt": "BRT"
    },
    "America/Belize": {
      "offset": -6,
      "hem": "n",
      "shrt": "CST|CDT"
    },
    "America/Boa_Vista": {
      "offset": -4,
      "hem": "n",
      "shrt": "AMT"
    },
    "America/Bogota": {
      "offset": -5,
      "hem": "n",
      "shrt": "COT"
    },
    "America/Boise": {
      "offset": -7,
      "hem": "n",
      "dst": "usa",
      "shrt": "MST|MDT"
    },
    "America/Cambridge_Bay": {
      "offset": -7,
      "hem": "n",
      "dst": "usa",
      "shrt": "MST|MDT"
    },
    "America/Campo_Grande": {
      "offset": -4,
      "hem": "s",
      "shrt": "AMT"
    },
    "America/Cancun": {
      "offset": -5,
      "hem": "n",
      "shrt": "EST|EDT"
    },
    "America/Caracas": {
      "offset": -4,
      "hem": "n",
      "shrt": "VET"
    },
    "America/Cayenne": {
      "offset": -3,
      "hem": "n",
      "shrt": "GFT"
    },
    "America/Chicago": {
      "offset": -6,
      "hem": "n",
      "dst": "usa",
      "shrt": "CST|CDT"
    },
    "America/Chihuahua": {
      "offset": -7,
      "hem": "n",
      "dst": "mex",
      "shrt": "HNPMX|HEPMX"
    },
    "America/Costa_Rica": {
      "offset": -6,
      "hem": "n",
      "shrt": "CST|CDT"
    },
    "America/Cuiaba": {
      "offset": -4,
      "hem": "s",
      "shrt": "AMT"
    },
    "America/Danmarkshavn": {
      "offset": 0,
      "hem": "n",
      "shrt": "GMT"
    },
    "America/Dawson": {
      "offset": -7,
      "hem": "n",
      "shrt": "MST|MDT"
    },
    "America/Dawson_Creek": {
      "offset": -7,
      "hem": "n",
      "shrt": "MST|MDT"
    },
    "America/Denver": {
      "offset": -7,
      "hem": "n",
      "dst": "usa",
      "shrt": "MST|MDT"
    },
    "America/Detroit": {
      "offset": -5,
      "hem": "n",
      "dst": "usa",
      "shrt": "EST|EDT"
    },
    "America/Edmonton": {
      "offset": -7,
      "hem": "n",
      "dst": "usa",
      "shrt": "MST|MDT"
    },
    "America/Eirunepe": {
      "offset": -5,
      "hem": "n",
      "shrt": "ACT"
    },
    "America/El_Salvador": {
      "offset": -6,
      "hem": "n",
      "shrt": "CST|CDT"
    },
    "America/Fort_Nelson": {
      "offset": -7,
      "hem": "n",
      "shrt": "MST|MDT"
    },
    "America/Fortaleza": {
      "offset": -3,
      "hem": "s",
      "shrt": "BRT"
    },
    "America/Glace_Bay": {
      "offset": -4,
      "hem": "n",
      "dst": "usa",
      "shrt": "AST|ADT"
    },
    "America/Nuuk": {
      "offset": -3,
      "hem": "n",
      "dst": "green",
      "shrt": "WGT|WGST"
    },
    "America/Goose_Bay": {
      "offset": -4,
      "hem": "n",
      "dst": "usa",
      "shrt": "AST|ADT"
    },
    "America/Grand_Turk": {
      "offset": -5,
      "hem": "n",
      "dst": "usa",
      "shrt": "EST|EDT"
    },
    "America/Guatemala": {
      "offset": -6,
      "hem": "n",
      "shrt": "CST|CDT"
    },
    "America/Guayaquil": {
      "offset": -5,
      "hem": "n",
      "shrt": "ECT"
    },
    "America/Guyana": {
      "offset": -4,
      "hem": "n",
      "shrt": "GYT"
    },
    "America/Halifax": {
      "offset": -4,
      "hem": "n",
      "dst": "usa",
      "shrt": "AST|ADT"
    },
    "America/Havana": {
      "offset": -5,
      "hem": "n",
      "dst": "cuba",
      "shrt": "HNCU|HECU"
    },
    "America/Hermosillo": {
      "offset": -7,
      "hem": "n",
      "shrt": "HNPMX|HEPMX"
    },
    "America/Inuvik": {
      "offset": -7,
      "hem": "n",
      "dst": "usa",
      "shrt": "MST|MDT"
    },
    "America/Iqaluit": {
      "offset": -5,
      "hem": "n",
      "dst": "usa",
      "shrt": "EST|EDT"
    },
    "America/Jamaica": {
      "offset": -5,
      "hem": "n",
      "shrt": "EST|EDT"
    },
    "America/Juneau": {
      "offset": -9,
      "hem": "n",
      "dst": "usa",
      "shrt": "AKST|AKDT"
    },
    "America/La_Paz": {
      "offset": -4,
      "hem": "s",
      "shrt": "BOT"
    },
    "America/Lima": {
      "offset": -5,
      "hem": "s",
      "shrt": "PET"
    },
    "America/Los_Angeles": {
      "offset": -8,
      "hem": "n",
      "dst": "usa",
      "shrt": "PST|PDT"
    },
    "America/Maceio": {
      "offset": -3,
      "hem": "n",
      "shrt": "BRT"
    },
    "America/Managua": {
      "offset": -6,
      "hem": "n",
      "shrt": "CST|CDT"
    },
    "America/Manaus": {
      "offset": -4,
      "hem": "s",
      "shrt": "AMT"
    },
    "America/Martinique": {
      "offset": -4,
      "hem": "n",
      "shrt": "AST|ADT"
    },
    "America/Matamoros": {
      "offset": -6,
      "hem": "n",
      "dst": "usa",
      "shrt": "CST|CDT"
    },
    "America/Mazatlan": {
      "offset": -7,
      "hem": "n",
      "dst": "mex",
      "shrt": "HNPMX|HEPMX"
    },
    "America/Menominee": {
      "offset": -6,
      "hem": "n",
      "dst": "usa",
      "shrt": "CST|CDT"
    },
    "America/Merida": {
      "offset": -6,
      "hem": "n",
      "dst": "mex",
      "shrt": "CST|CDT"
    },
    "America/Metlakatla": {
      "offset": -9,
      "hem": "n",
      "dst": "usa",
      "shrt": "AKST|AKDT"
    },
    "America/Mexico_City": {
      "offset": -6,
      "hem": "n",
      "dst": "mex",
      "shrt": "CST|CDT"
    },
    "America/Miquelon": {
      "offset": -3,
      "hem": "n",
      "dst": "usa",
      "shrt": "HNPM|HEPM"
    },
    "America/Moncton": {
      "offset": -4,
      "hem": "n",
      "dst": "usa",
      "shrt": "AST|ADT"
    },
    "America/Monterrey": {
      "offset": -6,
      "hem": "n",
      "dst": "mex",
      "shrt": "CST|CDT"
    },
    "America/Montevideo": {
      "offset": -3,
      "hem": "s",
      "shrt": "UYT"
    },
    "America/New_York": {
      "offset": -5,
      "hem": "n",
      "dst": "usa",
      "shrt": "EST|EDT"
    },
    "America/Nipigon": {
      "offset": -5,
      "hem": "n",
      "dst": "usa",
      "shrt": "EST|EDT"
    },
    "America/Nome": {
      "offset": -9,
      "hem": "n",
      "dst": "usa",
      "shrt": "AKST|AKDT"
    },
    "America/Noronha": {
      "offset": -2,
      "hem": "n",
      "shrt": "FNT"
    },
    "America/Ojinaga": {
      "offset": -7,
      "hem": "n",
      "dst": "usa",
      "shrt": "MST|MDT"
    },
    "America/Panama": {
      "offset": -5,
      "hem": "n",
      "shrt": "EST|EDT"
    },
    "America/Pangnirtung": {
      "offset": -5,
      "hem": "n",
      "dst": "usa",
      "shrt": "EST|EDT"
    },
    "America/Paramaribo": {
      "offset": -3,
      "hem": "n",
      "shrt": "SRT"
    },
    "America/Phoenix": {
      "offset": -7,
      "hem": "n",
      "shrt": "MST|MDT"
    },
    "America/Port-au-prince": {
      "offset": -5,
      "hem": "n",
      "dst": "usa",
      "shrt": "EST|EDT"
    },
    "America/Porto_Velho": {
      "offset": -4,
      "hem": "n",
      "shrt": "AMT"
    },
    "America/Puerto_Rico": {
      "offset": -4,
      "hem": "n",
      "shrt": "AST|ADT"
    },
    "America/Punta_Arenas": {
      "offset": -3,
      "hem": "s",
      "shrt": "CLT|CLST"
    },
    "America/Rainy_River": {
      "offset": -6,
      "hem": "n",
      "dst": "usa",
      "shrt": "CST|CDT"
    },
    "America/Rankin_Inlet": {
      "offset": -6,
      "hem": "n",
      "dst": "usa",
      "shrt": "CST|CDT"
    },
    "America/Recife": {
      "offset": -3,
      "hem": "n",
      "shrt": "BRT"
    },
    "America/Regina": {
      "offset": -6,
      "hem": "n",
      "shrt": "CST|CDT"
    },
    "America/Resolute": {
      "offset": -6,
      "hem": "n",
      "dst": "usa",
      "shrt": "CST|CDT"
    },
    "America/Rio_Branco": {
      "offset": -5,
      "hem": "s",
      "shrt": "ACT"
    },
    "America/Santarem": {
      "offset": -3,
      "hem": "n",
      "shrt": "BRT"
    },
    "America/Santiago": {
      "offset": -4,
      "hem": "s",
      "dst": "chile",
      "shrt": "CLT|CLST"
    },
    "America/Santo_Domingo": {
      "offset": -4,
      "hem": "n",
      "shrt": "AST|ADT"
    },
    "America/Sao_Paulo": {
      "offset": -3,
      "hem": "s",
      "shrt": "BRT"
    },
    "America/Scoresbysund": {
      "offset": -1,
      "hem": "n",
      "dst": "eu0",
      "shrt": "HNEG|HEEG"
    },
    "America/Sitka": {
      "offset": -9,
      "hem": "n",
      "dst": "usa",
      "shrt": "AKST|AKDT"
    },
    "America/St_Johns": {
      "offset": -3.5,
      "hem": "n",
      "dst": "usa",
      "shrt": "HNTN|HETN"
    },
    "America/Swift_Current": {
      "offset": -6,
      "hem": "n",
      "shrt": "CST|CDT"
    },
    "America/Tegucigalpa": {
      "offset": -6,
      "hem": "n",
      "shrt": "CST|CDT"
    },
    "America/Thule": {
      "offset": -4,
      "hem": "n",
      "dst": "usa",
      "shrt": "AST|ADT"
    },
    "America/Thunder_Bay": {
      "offset": -5,
      "hem": "n",
      "dst": "usa",
      "shrt": "EST|EDT"
    },
    "America/Tijuana": {
      "offset": -8,
      "hem": "n",
      "dst": "usa",
      "shrt": "PST|PDT"
    },
    "America/Toronto": {
      "offset": -5,
      "hem": "n",
      "dst": "usa",
      "shrt": "EST|EDT"
    },
    "America/Vancouver": {
      "offset": -8,
      "hem": "n",
      "dst": "usa",
      "shrt": "PST|PDT"
    },
    "America/Whitehorse": {
      "offset": -7,
      "hem": "n",
      "shrt": "MST|MDT"
    },
    "America/Winnipeg": {
      "offset": -6,
      "hem": "n",
      "dst": "usa",
      "shrt": "CST|CDT"
    },
    "America/Yakutat": {
      "offset": -9,
      "hem": "n",
      "dst": "usa",
      "shrt": "AKST|AKDT"
    },
    "America/Yellowknife": {
      "offset": -7,
      "hem": "n",
      "dst": "usa",
      "shrt": "MST|MDT"
    },
    "Antarctica/Casey": {
      "offset": 8,
      "hours": 3,
      "hem": "s",
      "dst": "ant",
      "shrt": "CAST|CAST"
    },
    "Antarctica/Davis": {
      "offset": 7,
      "hem": "s",
      "shrt": "DAVT"
    },
    "Antarctica/Macquarie": {
      "offset": 11,
      "hem": "s",
      "dst": "aus",
      "shrt": "AEST|AEDT"
    },
    "Antarctica/Mawson": {
      "offset": 5,
      "hem": "s",
      "shrt": "MAWT"
    },
    "Antarctica/Rothera": {
      "offset": -3,
      "hem": "s",
      "shrt": "ART"
    },
    "Antarctica/Troll": {
      "offset": 2,
      "hem": "s",
      "dst": "troll",
      "shrt": "GMT"
    },
    "Antarctica/Vostok": {
      "offset": 6,
      "hem": "s",
      "shrt": "MSK+4"
    },
    "Asia/Almaty": {
      "offset": 6,
      "hem": "n",
      "shrt": "ALMT"
    },
    "Asia/Amman": {
      "offset": 2,
      "hem": "n",
      "dst": "jord",
      "shrt": "EET|EEST"
    },
    "Asia/Anadyr": {
      "offset": 12,
      "hem": "n",
      "shrt": "ANAT"
    },
    "Asia/Aqtau": {
      "offset": 5,
      "hem": "n",
      "shrt": "ALMT"
    },
    "Asia/Aqtobe": {
      "offset": 5,
      "hem": "n",
      "shrt": "ALMT"
    },
    "Asia/Ashgabat": {
      "offset": 5,
      "hem": "n",
      "shrt": "TMT"
    },
    "Asia/Atyrau": {
      "offset": 5,
      "hem": "n",
      "shrt": "ALMT"
    },
    "Asia/Baghdad": {
      "offset": 3,
      "hem": "n",
      "shrt": "AST"
    },
    "Asia/Baku": {
      "offset": 4,
      "hem": "n",
      "shrt": "AZT"
    },
    "Asia/Bangkok": {
      "offset": 7,
      "hem": "n",
      "shrt": "ICT"
    },
    "Asia/Barnaul": {
      "offset": 7,
      "hem": "n",
      "shrt": "KRAT"
    },
    "Asia/Beirut": {
      "offset": 2,
      "hem": "n",
      "dst": "leb",
      "shrt": "EET|EEST"
    },
    "Asia/Bishkek": {
      "offset": 6,
      "hem": "n",
      "shrt": "KGT"
    },
    "Asia/Brunei": {
      "offset": 8,
      "hem": "n",
      "shrt": "BNT"
    },
    "Asia/Kolkata": {
      "offset": 5.5,
      "hem": "n",
      "shrt": "IST"
    },
    "Asia/Chita": {
      "offset": 9,
      "hem": "n",
      "shrt": "YAKT"
    },
    "Asia/Choibalsan": {
      "offset": 8,
      "hem": "n",
      "shrt": "ULAT"
    },
    "Asia/Colombo": {
      "offset": 5.5,
      "hem": "n",
      "shrt": "IST"
    },
    "Asia/Damascus": {
      "offset": 2,
      "hem": "n",
      "dst": "syr",
      "shrt": "EET|EEST"
    },
    "Asia/Dhaka": {
      "offset": 6,
      "hem": "n",
      "shrt": "BST"
    },
    "Asia/Dili": {
      "offset": 9,
      "hem": "s",
      "shrt": "TLT"
    },
    "Asia/Dubai": {
      "offset": 4,
      "hem": "n",
      "shrt": "GST"
    },
    "Asia/Dushanbe": {
      "offset": 5,
      "hem": "n",
      "shrt": "TJT"
    },
    "Asia/Famagusta": {
      "offset": 2,
      "hem": "n",
      "dst": "eu3",
      "shrt": "EET|EEST"
    },
    "Asia/Gaza": {
      "offset": 2,
      "hem": "n",
      "dst": "pal",
      "shrt": "EET|EEST"
    },
    "Asia/Hebron": {
      "offset": 2,
      "hem": "n",
      "dst": "pal",
      "shrt": "EET|EEST"
    },
    "Asia/Hong_Kong": {
      "offset": 8,
      "hem": "n",
      "shrt": "HKT"
    },
    "Asia/Hovd": {
      "offset": 7,
      "hem": "n",
      "shrt": "HOVT"
    },
    "Asia/Irkutsk": {
      "offset": 8,
      "hem": "n",
      "shrt": "IRKT"
    },
    "Asia/Jakarta": {
      "offset": 7,
      "hem": "s",
      "shrt": "WIB"
    },
    "Asia/Jayapura": {
      "offset": 9,
      "hem": "s",
      "shrt": "WIT"
    },
    "Asia/Jerusalem": {
      "offset": 2,
      "hem": "n",
      "dst": "isr",
      "shrt": "IST|IDT"
    },
    "Asia/Kabul": {
      "offset": 4.5,
      "hem": "n",
      "shrt": "AFT"
    },
    "Asia/Kamchatka": {
      "offset": 12,
      "hem": "n",
      "shrt": "PETT"
    },
    "Asia/Karachi": {
      "offset": 5,
      "hem": "n",
      "shrt": "PKT"
    },
    "Asia/Kathmandu": {
      "offset": 5.75,
      "hem": "n",
      "shrt": "NPT"
    },
    "Asia/Khandyga": {
      "offset": 9,
      "hem": "n",
      "shrt": "YAKT"
    },
    "Asia/Krasnoyarsk": {
      "offset": 7,
      "hem": "n",
      "shrt": "KRAT"
    },
    "Asia/Kuala_Lumpur": {
      "offset": 8,
      "hem": "s",
      "shrt": "MYT"
    },
    "Asia/Kuching": {
      "offset": 8,
      "hem": "n",
      "shrt": "MYT"
    },
    "Asia/Macau": {
      "offset": 8,
      "hem": "n",
      "shrt": "CST"
    },
    "Asia/Magadan": {
      "offset": 11,
      "hem": "n",
      "shrt": "MAGT"
    },
    "Asia/Makassar": {
      "offset": 8,
      "hem": "s",
      "shrt": "WITA"
    },
    "Asia/Manila": {
      "offset": 8,
      "hem": "n",
      "shrt": "PHST"
    },
    "Asia/Nicosia": {
      "offset": 2,
      "hem": "n",
      "dst": "eu3",
      "shrt": "EET|EEST"
    },
    "Asia/Novokuznetsk": {
      "offset": 7,
      "hem": "n",
      "shrt": "KRAT"
    },
    "Asia/Novosibirsk": {
      "offset": 7,
      "hem": "n",
      "shrt": "NOVT"
    },
    "Asia/Omsk": {
      "offset": 6,
      "hem": "n",
      "shrt": "OMST"
    },
    "Asia/Oral": {
      "offset": 5,
      "hem": "n",
      "shrt": "ALMT"
    },
    "Asia/Pontianak": {
      "offset": 7,
      "hem": "n",
      "shrt": "WIB"
    },
    "Asia/Pyongyang": {
      "offset": 9,
      "hem": "n",
      "shrt": "KST"
    },
    "Asia/Qatar": {
      "offset": 3,
      "hem": "n",
      "shrt": "AST"
    },
    "Asia/Qyzylorda": {
      "offset": 6,
      "hem": "n",
      "shrt": "ALMT"
    },
    "Asia/Qostanay": {
      "offset": 6,
      "hem": "n",
      "shrt": "ALMT"
    },
    "Asia/Yangon": {
      "offset": 6.5,
      "hem": "n",
      "shrt": "MMT"
    },
    "Asia/Riyadh": {
      "offset": 3,
      "hem": "n",
      "shrt": "AST"
    },
    "Asia/Ho_Chi_Minh": {
      "offset": 7,
      "hem": "n",
      "shrt": "ICT"
    },
    "Asia/Sakhalin": {
      "offset": 11,
      "hem": "n",
      "shrt": "SAKT"
    },
    "Asia/Samarkand": {
      "offset": 5,
      "hem": "n",
      "shrt": "UZT"
    },
    "Asia/Seoul": {
      "offset": 9,
      "hem": "n",
      "shrt": "KST"
    },
    "Asia/Shanghai": {
      "offset": 8,
      "hem": "n",
      "shrt": "CST"
    },
    "Asia/Singapore": {
      "offset": 8,
      "hem": "s",
      "shrt": "SGT"
    },
    "Asia/Srednekolymsk": {
      "offset": 12,
      "hem": "n",
      "shrt": "SRET"
    },
    "Asia/Taipei": {
      "offset": 8,
      "hem": "n",
      "shrt": "CST"
    },
    "Asia/Tashkent": {
      "offset": 5,
      "hem": "n",
      "shrt": "UZT"
    },
    "Asia/Tbilisi": {
      "offset": 4,
      "hem": "n",
      "shrt": "GET"
    },
    "Asia/Tehran": {
      "offset": 3.5,
      "hem": "n",
      "dst": "iran",
      "shrt": "IRST|IRDT"
    },
    "Asia/Thimphu": {
      "offset": 6,
      "hem": "n",
      "shrt": "BT"
    },
    "Asia/Tokyo": {
      "offset": 9,
      "hem": "n",
      "shrt": "JST"
    },
    "Asia/Tomsk": {
      "offset": 7,
      "hem": "n",
      "shrt": "OMST"
    },
    "Asia/Ulaanbaatar": {
      "offset": 8,
      "hem": "n",
      "shrt": "ULAT"
    },
    "Asia/Ust-nera": {
      "offset": 10,
      "hem": "n",
      "shrt": "VLAT"
    },
    "Asia/Vladivostok": {
      "offset": 10,
      "hem": "n",
      "shrt": "VLAT"
    },
    "Asia/Yakutsk": {
      "offset": 10,
      "hem": "n",
      "shrt": "YAKT"
    },
    "Asia/Yekaterinburg": {
      "offset": 5,
      "hem": "n",
      "shrt": "YEKT"
    },
    "Asia/Yerevan": {
      "offset": 4,
      "hem": "n",
      "shrt": "AMT"
    },
    "Atlantic/Azores": {
      "offset": -1,
      "hem": "n",
      "dst": "eu0",
      "shrt": "AZOT|AZOST"
    },
    "Atlantic/Bermuda": {
      "offset": -4,
      "hem": "n",
      "dst": "usa",
      "shrt": "AST|ADT"
    },
    "Atlantic/Canary": {
      "offset": 0,
      "hem": "n",
      "dst": "eu1",
      "shrt": "WET|WEST"
    },
    "Atlantic/Cape_Verde": {
      "offset": -1,
      "hem": "n",
      "shrt": "CVT"
    },
    "Atlantic/Faroe": {
      "offset": 0,
      "hem": "n",
      "dst": "eu1",
      "shrt": "WET|WEST"
    },
    "Atlantic/Madeira": {
      "offset": 0,
      "hem": "n",
      "dst": "eu1",
      "shrt": "WET|WEST"
    },
    "Atlantic/Reykjavik": {
      "offset": 0,
      "hem": "n",
      "shrt": "GMT"
    },
    "Atlantic/South_Georgia": {
      "offset": -2,
      "hem": "n",
      "shrt": "GST"
    },
    "Atlantic/Stanley": {
      "offset": -3,
      "hem": "s",
      "shrt": "FKST"
    },
    "Australia/Adelaide": {
      "offset": 9.5,
      "hem": "s",
      "dst": "aus",
      "shrt": "ACST|ACDT"
    },
    "Australia/Brisbane": {
      "offset": 10,
      "hem": "s",
      "shrt": "AEST"
    },
    "Australia/Broken_Hill": {
      "offset": 9.5,
      "hem": "s",
      "dst": "aus",
      "shrt": "ACST|ACDT"
    },
    "Australia/Darwin": {
      "offset": 9.5,
      "hem": "s",
      "shrt": "ACST"
    },
    "Australia/Eucla": {
      "offset": 8.75,
      "hem": "s",
      "shrt": "ACWST"
    },
    "Australia/Hobart": {
      "offset": 10,
      "hem": "s",
      "dst": "aus",
      "shrt": "AEST|AEDT"
    },
    "Australia/Lindeman": {
      "offset": 10,
      "hem": "s",
      "shrt": "AEST"
    },
    "Australia/Lord_Howe": {
      "offset": 10.5,
      "change": 0.5,
      "hem": "s",
      "dst": "lhow",
      "shrt": "LHST|LHDT"
    },
    "Australia/Melbourne": {
      "offset": 10,
      "hem": "s",
      "dst": "aus",
      "shrt": "AEST|AEDT"
    },
    "Australia/Perth": {
      "offset": 8,
      "hem": "s",
      "shrt": "AWST"
    },
    "Australia/Sydney": {
      "offset": 10,
      "hem": "s",
      "dst": "aus",
      "shrt": "AEST|AEDT"
    },
    "Europe/Amsterdam": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Andorra": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Astrakhan": {
      "offset": 4,
      "hem": "n",
      "shrt": "MSK"
    },
    "Europe/Athens": {
      "offset": 2,
      "hem": "n",
      "dst": "eu3",
      "shrt": "EET|EEST"
    },
    "Europe/Belgrade": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Brussels": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Bucharest": {
      "offset": 2,
      "hem": "n",
      "dst": "eu3",
      "shrt": "EET|EEST"
    },
    "Europe/Budapest": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Busingen": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Chisinau": {
      "offset": 2,
      "hem": "n",
      "dst": "eu2",
      "shrt": "EET|EEST"
    },
    "Europe/Copenhagen": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Dublin": {
      "offset": 0,
      "hem": "n",
      "dst": "eu1",
      "shrt": "GMT|IST"
    },
    "Europe/Gibraltar": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Helsinki": {
      "offset": 2,
      "hem": "n",
      "dst": "eu3",
      "shrt": "EET|EEST"
    },
    "Europe/Istanbul": {
      "offset": 3,
      "hem": "n",
      "shrt": "TRT"
    },
    "Europe/Kaliningrad": {
      "offset": 2,
      "hem": "n",
      "shrt": "EET|EEST"
    },
    "Europe/Kirov": {
      "offset": 3,
      "hem": "n",
      "shrt": "MSK"
    },
    "Europe/Kiev": {
      "offset": 2,
      "hem": "n",
      "dst": "eu3",
      "shrt": "EET|EEST"
    },
    "Europe/Lisbon": {
      "offset": 0,
      "hem": "n",
      "dst": "eu1",
      "shrt": "WET|WEST"
    },
    "Europe/London": {
      "offset": 0,
      "hem": "n",
      "dst": "eu1",
      "shrt": "GMT|BST"
    },
    "Europe/Luxembourg": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Madrid": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Malta": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Minsk": {
      "offset": 3,
      "hem": "n",
      "shrt": "MSK"
    },
    "Europe/Monaco": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Moscow": {
      "offset": 3,
      "hem": "n",
      "shrt": "MSK"
    },
    "Europe/Oslo": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Paris": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Prague": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Riga": {
      "offset": 2,
      "hem": "n",
      "dst": "eu3",
      "shrt": "EET|EEST"
    },
    "Europe/Rome": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Samara": {
      "offset": 4,
      "hem": "n",
      "shrt": "SAMT"
    },
    "Europe/Saratov": {
      "offset": 4,
      "hem": "n",
      "shrt": "SAMT"
    },
    "Europe/Sofia": {
      "offset": 2,
      "hem": "n",
      "dst": "eu3",
      "shrt": "EET|EEST"
    },
    "Europe/Stockholm": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Tallinn": {
      "offset": 2,
      "hem": "n",
      "dst": "eu3",
      "shrt": "EET|EEST"
    },
    "Europe/Tirane": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Ulyanovsk": {
      "offset": 4,
      "hem": "n",
      "shrt": "MSK"
    },
    "Europe/Uzhgorod": {
      "offset": 2,
      "hem": "n",
      "dst": "eu3",
      "shrt": "EET|EEST"
    },
    "Europe/Vienna": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Vilnius": {
      "offset": 2,
      "hem": "n",
      "dst": "eu3",
      "shrt": "EET|EEST"
    },
    "Europe/Volgograd": {
      "offset": 4,
      "hem": "n",
      "shrt": "MSK"
    },
    "Europe/Warsaw": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Europe/Zaporozhye": {
      "offset": 2,
      "hem": "n",
      "dst": "eu3",
      "shrt": "EET|EEST"
    },
    "Europe/Zurich": {
      "offset": 1,
      "hem": "n",
      "dst": "eu2",
      "shrt": "CET|CEST"
    },
    "Indian/Chagos": {
      "offset": 6,
      "hem": "n",
      "shrt": "IOT"
    },
    "Indian/Christmas": {
      "offset": 7,
      "hem": "s",
      "shrt": "CXT"
    },
    "Indian/Cocos": {
      "offset": 6.5,
      "hem": "n",
      "shrt": "CCT"
    },
    "Indian/Kerguelen": {
      "offset": 5,
      "hem": "s",
      "shrt": "TFT"
    },
    "Indian/Mahe": {
      "offset": 4,
      "hem": "n",
      "shrt": "SCT"
    },
    "Indian/Maldives": {
      "offset": 5,
      "hem": "n",
      "shrt": "MVT"
    },
    "Indian/Mauritius": {
      "offset": 4,
      "hem": "n",
      "shrt": "MUT"
    },
    "Indian/Reunion": {
      "offset": 4,
      "hem": "s",
      "shrt": "RET"
    },
    "Pacific/Apia": {
      "offset": 13,
      "hem": "s",
      "shrt": "WST|WST"
    },
    "Pacific/Auckland": {
      "offset": 12,
      "hem": "s",
      "dst": "nz",
      "shrt": "NZST|NZDT"
    },
    "Pacific/Bougainville": {
      "offset": 11,
      "hem": "s",
      "shrt": "PGT"
    },
    "Pacific/Chatham": {
      "offset": 12.75,
      "hem": "s",
      "dst": "chat",
      "shrt": "CHAST|CHADT"
    },
    "Pacific/Easter": {
      "offset": -6,
      "hem": "s",
      "dst": "east",
      "shrt": "EAST|EASST"
    },
    "Pacific/Efate": {
      "offset": 11,
      "hem": "n",
      "shrt": "VUT"
    },
    "Pacific/Kanton": {
      "offset": 13,
      "hem": "n",
      "shrt": "PHOT"
    },
    "Pacific/Fakaofo": {
      "offset": 13,
      "hem": "n",
      "shrt": "TKT"
    },
    "Pacific/Fiji": {
      "offset": 12,
      "hem": "s",
      "dst": "fiji",
      "shrt": "FJT|FJT"
    },
    "Pacific/Funafuti": {
      "offset": 12,
      "hem": "n",
      "shrt": "TVT"
    },
    "Pacific/Galapagos": {
      "offset": -6,
      "hem": "n",
      "shrt": "COT"
    },
    "Pacific/Gambier": {
      "offset": -9,
      "hem": "n",
      "shrt": "GAMT"
    },
    "Pacific/Guadalcanal": {
      "offset": 11,
      "hem": "n",
      "shrt": "SBT"
    },
    "Pacific/Guam": {
      "offset": 10,
      "hem": "n",
      "shrt": "ChST"
    },
    "Pacific/Honolulu": {
      "offset": -10,
      "hem": "n",
      "shrt": "HAST|HADT"
    },
    "Pacific/Kiritimati": {
      "offset": 14,
      "hem": "n",
      "shrt": "LINT"
    },
    "Pacific/Kosrae": {
      "offset": 11,
      "hem": "n",
      "shrt": "KOST"
    },
    "Pacific/Kwajalein": {
      "offset": 12,
      "hem": "n",
      "shrt": "MHT"
    },
    "Pacific/Majuro": {
      "offset": 12,
      "hem": "n",
      "shrt": "MHT"
    },
    "Pacific/Marquesas": {
      "offset": -9.5,
      "hem": "n",
      "shrt": "MART"
    },
    "Pacific/Nauru": {
      "offset": 12,
      "hem": "n",
      "shrt": "NRT"
    },
    "Pacific/Niue": {
      "offset": -11,
      "hem": "n",
      "shrt": "NUT"
    },
    "Pacific/Norfolk": {
      "offset": 10.5,
      "hem": "n",
      "dst": "aus",
      "shrt": "NFT|NFDT"
    },
    "Pacific/Noumea": {
      "offset": 11,
      "hem": "n",
      "shrt": "NCT"
    },
    "Pacific/Pago_Pago": {
      "offset": -11,
      "hem": "n",
      "shrt": "SST"
    },
    "Pacific/Palau": {
      "offset": 9,
      "hem": "n",
      "shrt": "PWT"
    },
    "Pacific/Pitcairn": {
      "offset": -8,
      "hem": "n",
      "shrt": "PST"
    },
    "Pacific/Pohnpei": {
      "offset": 11,
      "hem": "n",
      "shrt": "PONT"
    },
    "Pacific/Port_Moresby": {
      "offset": 10,
      "hem": "s",
      "shrt": "PGT"
    },
    "Pacific/Rarotonga": {
      "offset": -10,
      "hem": "n",
      "shrt": "CKT"
    },
    "Pacific/Tahiti": {
      "offset": -10,
      "hem": "n",
      "shrt": "TAHT"
    },
    "Pacific/Tarawa": {
      "offset": 12,
      "hem": "n",
      "shrt": "GILT"
    },
    "Pacific/Tongatapu": {
      "offset": 13,
      "hem": "s",
      "shrt": "TOT"
    },
    "Pacific/Chuuk": {
      "offset": 10,
      "hem": "n",
      "shrt": "CHUT"
    },
    "Pacific/Wake": {
      "offset": 12,
      "hem": "n",
      "shrt": "WAKT"
    },
    "Pacific/Wallis": {
      "offset": 12,
      "hem": "n",
      "shrt": "WFT"
    },
    "Etc/GMT": {
      "offset": 0,
      "hem": "n",
      "shrt": "GMT"
    },
    "Etc/Utc": {
      "offset": 0,
      "hem": "n",
      "shrt": "UTC"
    },
    "America/Argentina/Buenos_Aires": {
      "offset": -3,
      "hem": "s",
      "shrt": "ART"
    },
    "America/Indiana/Knox": {
      "offset": -6,
      "hem": "n",
      "dst": "usa",
      "shrt": "CST|CDT"
    },
    "America/Indiana/Tell_City": {
      "offset": -6,
      "hem": "n",
      "dst": "usa",
      "shrt": "CST|CDT"
    },
    "America/North_Dakota/Beulah": {
      "offset": -6,
      "hem": "n",
      "dst": "usa",
      "shrt": "CST|CDT"
    },
    "America/North_Dakota/Center": {
      "offset": -6,
      "hem": "n",
      "dst": "usa",
      "shrt": "CST|CDT"
    },
    "America/North_Dakota/New_Salem": {
      "offset": -6,
      "hem": "n",
      "dst": "usa",
      "shrt": "CST|CDT"
    },
    "America/Indiana/Petersburg": {
      "offset": -5,
      "hem": "n",
      "dst": "usa",
      "shrt": "EST|EDT"
    },
  };

  // determine current day (mon, tues)
  // using 'Key-Value Method' from - https://artofmemory.com/blog/how-to-calculate-the-day-of-the-week/

  // const DAYS = [
  //   'Sunday',
  //   'Monday',
  //   'Tuesday',
  //   'Wednesday',
  //   'Thursday',
  //   'Friday',
  //   'Saturday',
  // ];

  const month_code = function (n) {
    let month_codes = [
      null,
      0, //January
      3, //February
      3, //March
      6, //April
      1, //May
      4, //June
      6, //July
      2, //August
      5, //September
      0, //October
      3, //November
      5, //December
    ];
    return month_codes[n]
  };

  const year_code = function (year) {
    let yy = year % 100;
    return (yy + parseInt(yy / 4, 10)) % 7;
  };

  const century_code = function (year) {
    //julian
    if (year < 1752) {
      let c = parseInt(year / 100, 10);
      return (18 - c) % 7;
    }
    //gregorian
    let c = parseInt(year / 100, 10);
    let codes = {
      '17': 4, // 1700s = 4
      '18': 2, // 1800s = 2
      '19': 0, // 1900s = 0
      '20': 6, // 2000s = 6
      '21': 4, // 2100s = 4
      '22': 2, // 2200s = 2
      '23': 0, // 2300s = 0
    };
    return codes[String(c)] || 0
  };

  // https://www.timeanddate.com/date/leapyear.html
  const leap_code = function (year) {
    let is_leap = (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    if (is_leap === true) {
      return -1
    } else {
      return 0
    }
  };

  // which day of the week is it?
  const getDay = function (year, month, date) {
    let yc = year_code(year);
    let mc = month_code(month);
    let cc = century_code(year);
    let dc = date;
    let lc = leap_code(year);
    // (Year Code + Month Code + Century Code + Date Number - Leap Year Code) mod 7
    let day = (yc + mc + cc + dc + lc) % 7;
    return day
    // return DAYS[day]
  };
  var getDay$1 = getDay;


  // 1969-07-20 - sunday
  // 1897-03-14 - sunday
  //1066-10-14 -sat
  // let cal = { year: 2022, month: 10, date: 13 }
  // let cal = { year: 1066, month: 10, date: 14 }
  // let cal = { year: 1897, month: 3, date: 14 }
  // let cal = { year: 1969, month: 7, date: 20 }

  var MONTHS = [
    { long: 'January', short: 'Jan', len: 31 },
    { long: 'February', short: 'Feb', len: 28 }, // 29 in a leap year
    { long: 'March', short: 'Mar', len: 31 },
    { long: 'April', short: 'Apr', len: 30 },
    { long: 'May', short: 'May', len: 31 },
    { long: 'June', short: 'Jun', len: 30 },
    { long: 'July', short: 'Jul', len: 31 },
    { long: 'August', short: 'Aug', len: 31 },
    { long: 'September', short: 'Sep', len: 30 },
    { long: 'October', short: 'Oct', len: 31 },
    { long: 'November', short: 'Nov', len: 30 },
    { long: 'December', short: 'Dec', len: 31 },
  ];

  const monthLengths$1 = MONTHS.map(o => o.len);

  const addMonths = function (months, year) {
    let ms = 0;
    for (let i = 0; i < months - 1; i += 1) {
      let days = monthLengths$1[i];
      if (i === 1 && isLeap(year)) {
        days = 29;
      }
      ms += days * DAY;
    }
    return ms
  };

  // click forward to the proper weekday
  const toWeekDay = function (obj, year) {
    let day = getDay$1(year, obj.month, 1);
    let want = obj.day;
    let diff = 0;
    for (let i = 0; i < 7; i += 1) {
      if (day === want) {
        return diff //* DAY
      }
      day += 1;
      day = day % 7;
      diff += 1;
    }
    return 0
  };


  const toRightWeek = function (num, day, month) {
    if (num === 'first' || num <= 1) {
      return 0
    }
    if (num === 'last') {
      let max = monthLengths$1[month + 1] || 31;
      let days = 0;
      for (let i = 0; i < 5; i += 1) {
        days += 7;
        if (days + day >= max) {
          return days - 7 //went too far
        }
      }
      console.log('fixme [toRightWeek]');//eslint-disable-line
      return 3
    }
    let days = (num - 1) * 7;
    return days // * DAY
  };


  const calc = function (obj, year, offset) {
    let date = 1;
    let month = obj.month;
    let epoch = getStart(year);
    // go to the correct month
    epoch += addMonths(obj.month, year);
    // go to the correct day
    let days = toWeekDay(obj, year);
    date += days;
    epoch += days * DAY;
    // go to the correct week
    days = toRightWeek(obj.num, days, obj.month);
    epoch += days * DAY;
    date += days;
    // go to the correct hour
    epoch += (obj.hour || 0) * HOUR;
    // go to the correct offset
    epoch -= offset * 60 * 60 * 1000;
    // console.log(new Date(epoch))
    return { epoch, month, date }
  };
  // 2nd tuesday
  // console.log(calc({ month: 10, day: 2, num: 2, hour: 2 }, 2022))

  var calc$1 = calc;

  let memo = {};

  // calculate DST times, for this timezone
  const getDst = function (tz, year) {
    // try and calculate each tz+year pair only once
    if (memo.hasOwnProperty(tz) && memo[tz].hasOwnProperty(year)) {
      return memo[tz][year]
    }
    memo[tz] = memo[tz] || {};

    let { dst, offset, change, hem } = zones[tz] || {};
    change = change || 1;

    let changes = [];

    let obj = patterns[dst];
    // if it has no dst..
    if (!obj) {
      memo[tz][year] = [];
      return changes
    }
    // get epoch for spring dst change
    let res = calc$1(obj.start, year, offset);
    // console.log(res)
    let delta = hem === 'n' ? change : 0;
    changes.push({
      epoch: res.epoch,
      cal: {
        year,
        month: res.month,
        date: res.date,
        hour: obj.start.hour,
        minute: 0,
        second: 0,
        millisecond: 0,
      },
      delta,
      offset: offset + delta
    });


    // get epoch for fall dst change
    res = calc$1(obj.end, year, offset);
    delta = hem === 's' ? change : 0;
    changes.push({
      epoch: res.epoch - HOUR, //todo fixme
      cal: {
        year,
        month: res.month,
        date: res.date,
        hour: obj.end.hour,
        minute: 0,
        second: 0,
        millisecond: 0,
      },
      delta,
      offset: offset + delta
    });
    // store it for next time
    memo[tz][year] = changes;

    // reverse dst change for southern-hemisphere
    if (hem === 's') {
      changes[0].epoch += HOUR * 1;
      changes[1].epoch += HOUR * 1;
    }
    return changes
  };

  var getDst$1 = getDst;

  // console.log(getDst('America/Toronto', 2023))
  // console.log(getDst('Australia/Adelaide', 2023))
  // console.log(getDst('Australia/Melbourne', 2010))

  const isFloat = function (n) {
    return n !== undefined && Number(n) === n && n % 1 !== 0;
  };

  // ensure we haven't been given any silly numbers
  const validate = function (cal) {
    Object.keys(cal).forEach(k => {
      // no decimals allowed
      if (isFloat(cal[k])) {
        cal[k] = parseInt(cal[k], 10);
      }
      // no negatives
      if (cal[k] < 0 && k !== 'year') {
        cal[k] = 0;
      }
    });

    // set defaults
    cal.month = cal.month || 1; //co-erce any zeros to 1s
    cal.date = cal.date || 1; // (same)
    cal.hour = cal.hour || 0;
    cal.minute = cal.minute || 0;
    cal.second = cal.second || 0;
    cal.millisecond = cal.millisecond || 0;

    // range maximums
    if (cal.month && cal.month > 12) {
      cal.month = 12;
    }
    if (cal.date && MONTHS[cal.month - 1] && cal.date > MONTHS[cal.month - 1].len) {
      // check leap
      if (cal.month === 2 && isLeap(cal.year)) {
        cal.date = 29;
      } else {
        cal.date = MONTHS[cal.month - 1].len;
      }
    }
    if (cal.hour && cal.hour > 24) {
      cal.month = 24;
    }
    if (cal.minute && cal.minute > 59) {
      cal.month = 59;
    }
    if (cal.second && cal.second > 59) {
      cal.second = 59;
    }
    if (cal.millisecond && cal.millisecond > 999) {
      cal.millisecond = 999;
    }
    return cal
  };
  var validate$1 = validate;

  // compare two cal objects
  const ensureEqual = function (a, b) {
    const units = ['year', 'month', 'date', 'hour', 'minute', 'second', 'millisecond'];
    for (let i = 0; i < units.length; i += 1) {
      let unit = units[i];
      if (a[unit] !== b[unit]) {
        console.error('\n----\nMis-matched unit in walk:', unit); // eslint-disable-line
        console.error(a, '\n', b); // eslint-disable-line
        return false
      }
    }
    //it's the same
    return true
  };

  const diffDays = function (from, to) {
    let diff = 0;
    // increment months
    for (let n = from.month; n < to.month; n += 1) {
      // console.log(`+${months[n - 1].len} for ${months[n - 1].long}`)
      diff += MONTHS[n - 1].len;
      if (n === 2 && isLeap(from.year)) {
        diff += 1; //add another
      }
    }
    // delta days (can be negative)
    let days = to.date - from.date;
    diff += days;
    return diff
  };

  // step forward and count milliseconds 
  // until the two calendar objects meet
  const walk$1 = function (epoch, from, to) {
    // console.log(`from: ${from.year}-${from.month}-${from.date}`)
    // console.log(`  to: ${to.year}-${to.month}-${to.date}`)

    // increment months/days  (we are guaranteed to be in the same year)
    let diff = diffDays(from, to);
    epoch += diff * DAY;
    from.month = to.month;
    from.date = to.date;

    // add-up remaining hours
    diff = to.hour - from.hour;
    epoch += diff * HOUR;
    from.hour += diff;

    // remaining minutes
    diff = to.minute - from.minute;
    epoch += diff * MINUTE;
    from.minute += diff;

    // add-up remaining seconds
    diff = to.second - from.second;
    epoch += diff * SECOND;
    from.second += diff;

    // add-up remaining milliseconds
    diff = to.millisecond - from.millisecond;
    epoch += diff;
    from.millisecond += diff;

    // make sure we are complete
    ensureEqual(from, to);

    return epoch
  };
  var walk$2 = walk$1;

  const NEW_YEAR = {
    month: 1,
    date: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  };

  // compare two cal objects
  const isAfter = function (a, b) {
    const units = ['year', 'month', 'date', 'hour', 'minute', 'second', 'millisecond'];
    for (let i = 0; i < units.length; i += 1) {
      let unit = units[i];
      if (a[unit] > b[unit]) {
        return true
      }
      if (a[unit] < b[unit]) {
        return false
      }
    }
    //it's the same
    return true
  };

  const getEpoch = function (cal, tz) {
    // set secure defaults
    cal = validate$1(cal);

    // set our cal to Jan 1 of this year
    let epoch = getStart(cal.year, tz);
    let have = Object.assign({}, NEW_YEAR, { year: cal.year });

    // consult any DST changes this year
    let changes = getDst$1(tz, cal.year).reverse();
    let change = changes.find(c => isAfter(cal, c.cal));
    if (change) {
      epoch = change.epoch;
      have = Object.assign({}, NEW_YEAR, change.cal, { year: cal.year });
    }

    // step-forward, by milliseconds
    epoch = walk$2(epoch, have, cal);

    //there is no year 0, so bc years are off by 1
    // if (cal.year < 0) {
    // epoch += YEAR
    // }
    return epoch
  };
  var getEpoch$1 = getEpoch;

  var aliases$2 = {

  };

  let mapping$3 = { z: 'Etc/GMT' };
  Object.keys(zones$2).forEach(k => {
    mapping$3[k.toLowerCase()] = k;
  });

  const findTz = function (str) {
    str = str || '';
    if (zones$2.hasOwnProperty(str)) {
      return str
    }
    str = str.toLowerCase().trim();
    if (aliases$2.hasOwnProperty(str)) {
      return aliases$2[str]
    }
    if (mapping$3.hasOwnProperty(str)) {
      return mapping$3[str]
    }
    return config.fallbackTz
  };
  var findTz$1 = findTz;

  const isNum = val => typeof val === 'number';

  let mapping$2 = {};
  config.months.longForm.forEach((str, i) => {
    mapping$2[str.toLowerCase()] = i + 1;
    let shrt = config.months.shortForm[i] || '';
    mapping$2[shrt.toLowerCase()] = i + 1;
  });
  mapping$2.sept = 9;//extra

  const parseMonth = function (input) {
    if (isNum(input)) {
      return input
    }
    input = input.toLowerCase().trim();
    return mapping$2[input]
  };
  var parseMonth$1 = parseMonth;

  // parse '+05:30' offset according to ISO8601 - 
  //  could be +hh:mm, +hhmm or +hh
  const reg = /^([+-])?([0-9]{1,2}):?([0-9]{2})?$/;

  //pull-apart ISO offsets, like "+0100"
  const parseOffset = (str) => {
    if (!str) {
      return null
    }
    // 'Zulu' is 0
    if (str === 'Z' || str === 'z') {
      return 0
    }
    // tokenize it
    let m = str.match(reg);
    if (m !== null) {
      let [, plus, hour, min] = m;

      hour = parseInt(hour || '', 10) || 0;
      min = parseInt(min || '', 10) || 0;

      // turn minutes into decimal - 30 -> 0.5
      min = min / 60;

      let offset = hour + min;

      // handle negative
      if (plus === '-') {
        offset *= -1;
      }
      return offset
    }
    return null

    //okay, try to match it to a utc timezone
    //remember - this is opposite! a -5 offset maps to Etc/GMT+5  ¯\_(:/)_/¯
    //https://askubuntu.com/questions/519550/why-is-the-8-timezone-called-gmt-8-in-the-filesystem
    // num *= -1
    // return num

    // if (num >= 0) {
    //   num = '+' + num
    // }
    // let tz = 'etc/gmt' + num
    // let zones = s.timezones
    // if (zones[tz]) {
    // log a warning if we're over-writing a given timezone?
    // console.log('changing timezone to: ' + tz)
    // s.tz = tz
    // }
    // return s
  };
  var parseOffset$1 = parseOffset;

  const parseHour = function (str) {
    if (isNum(str)) {
      return str
    }
    str = str.trim().toLowerCase();
    // leading 0s
    str = str.replace(/^[0:]+/, '');
    // '4h'
    str = str.replace(/([0-9])h$/, '$1');
    // '4'
    let n = parseInt(str, 10);
    if (n) {
      return n
    }
    //'5pm'
    let m = str.match(/([0-9]+) ?(am|pm)$/);
    if (m !== null && m[1]) {
      let h = Number(m[1]);
      if (m[2] === 'pm') {
        h += 12;
      }
      return h
    }
    return 0
  };
  var parseHour$1 = parseHour;

  const startOfDay = {
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  };


  // truncate any sub-millisecond values
  const parseMs = function (str = '') {
    str = String(str);
    //js does not support sub-millisecond values 
    // so truncate these - 2021-11-02T19:55:30.087772
    if (str.length > 3) {
      str = str.substring(0, 3);
    } else if (str.length === 1) {
      // assume ms are zero-padded on the left
      // but maybe not on the right.
      // turn '.10' into '.100'
      str = str + '00';
    } else if (str.length === 2) {
      str = str + '0';
    }
    return Number(str) || 0
  };

  const parseTime = (str = '', obj) => {
    obj = Object.assign({}, startOfDay, obj);
    // remove all whitespace
    str = str.replace(/^\s+/, '').toLowerCase();
    //formal time format - 04:30.23
    let arr = str.match(/([0-9]{1,2}):([0-9]{1,2}):?([0-9]{1,2})?[:.]?([0-9]{1,4})?/);
    if (arr !== null) {
      //validate it a little
      let h = Number(arr[1]);
      if (h < 0 || h > 24) {
        return obj
      }
      let m = Number(arr[2]); //don't accept '5:3pm'
      if (arr[2].length < 2 || m < 0 || m > 59) {
        return obj
      }
      obj.hour = h;
      obj.minute = m;
      obj.second = Number(arr[3]) || 0;
      obj.millisecond = parseMs(arr[4]);
      //parse-out am/pm
      let ampm = str.match(/[\\b0-9] ?(am|pm)\b/);
      if (ampm !== null && ampm[1] === 'pm') {
        obj.hour += 12;
      }
      return obj
    }

    // parse hour-only times
    let h = parseHour$1(str);
    if (h !== null) {
      obj.hour = h;
    }
    return obj
  };
  var parseTime$1 = parseTime;

  const parseYear = (str = '') => {
    if (isNum(str)) {
      return str
    }
    str = str.trim();
    // parse '86 shorthand
    if (/^'[0-9][0-9]$/.test(str) === true) {
      let num = Number(str.replace(/'/, ''));
      if (num > 50) {
        return 1900 + num
      }
      return 2000 + num
    }
    let year = parseInt(str, 10);
    // use a given year from options.today
    // if (!year && today) {
    //   year = today.year
    // }
    // fallback to this year
    year = year || new Date().getFullYear();//remove me
    return year
  };

  var parseYear$1 = parseYear;

  const parseDate = (str = '') => {
    if (isNum(str)) {
      return str
    }
    str = str.trim();
    // remove padding
    str = str.replace(/^0+/, '');

    //remove ordinal suffix
    str = str.replace(/([0-9])(st|nd|rd|th)$/i, '$1');

    let date = parseInt(str, 10);

    return date || 1 // coerce zero to one
  };

  var parseDate$1 = parseDate;

  const ampm = function (str) {
    str = str.trim().toLowerCase();
    // a.m.
    str = str.replace(/\./g, '');
    if (str === 'am' || str === 'pm') {
      return str
    }
    return null
  };
  var parseAmpm = ampm;

  var ymd = [
    // =====
    //  y-m-d
    // =====
    //iso-this 1998-05-30T22:00:00:000Z, iso-that 2017-04-03T08:00:00-0700
    {
      reg: /^(-?0{0,2}[0-9]{3,4})-([0-9]{1,2})-([0-9]{1,2})[T| ]([0-9.:]+)(Z|[0-9\-+:]+)?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[1]),
          month: parseInt(m[2], 10),
          date: parseDate$1(m[3])
        };
        obj.offset = parseOffset$1(m[5]);
        obj = parseTime$1(m[4], obj);
        return obj
      }
    },
    //short-iso "2015-03-25" or "2015/03/25" or "2015/03/25 12:26:14 PM"
    {
      reg: /^([0-9]{4})[-/. ]([0-9]{1,2})[-/. ]([0-9]{1,2})( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[1]),
          month: parseInt(m[2], 10),
          date: parseDate$1(m[3])
        };
        if (obj.month > 12) {
          //support yyyy/dd/mm (weird, but ok)
          obj.date = parseDate$1(m[2]);
          obj.month = parseInt(m[3], 10);
        }
        obj = parseTime$1(m[4], obj);
        return obj
      }
    },

    //text-month "2015-feb-25"
    {
      reg: /^([0-9]{4})[-/. ]([a-z]+)[-/. ]([0-9]{1,2})( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[1]),
          month: parseMonth$1(m[2]),
          date: parseDate$1(m[3] || '')
        };
        obj = parseTime$1(m[4], obj);
        return obj
      }
    }
  ];

  var mdy = [
    // =====
    //  m-d-y
    // =====
    //mm/dd/yyyy - uk/canada "6/28/2019, 12:26:14 PM"
    {
      reg: /^([0-9]{1,2})[-/.]([0-9]{1,2})[-/.]?([0-9]{4})?( [0-9]{1,2}:[0-9]{2}:?[0-9]{0,2} ?(am|pm|gmt))?$/i,
      parse: (m) => {
        let month = parseInt(m[1], 10);
        let date = parseDate$1(m[2]);
        //support dd/mm/yyy
        // if (s.british || month >= 12) {
        //   date = parseInt(m[1], 10)
        //   month = parseInt(m[2], 10) - 1
        // }
        let obj = {
          date,
          month,
          year: parseYear$1(m[3])
        };
        // s = parseTime(s, m[4])
        return obj
      }
    },
    //alt short format - "feb-25-2015"
    {
      reg: /^([a-z]+)[-/. ]([0-9]{1,2})[-/. ]?([0-9]{4}|'[0-9]{2})?( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[3]),
          month: parseMonth$1(m[1]),
          date: parseDate$1(m[2] || '')
        };
        obj = parseTime$1(m[4], obj);
        return obj
      }
    },

    //Long "Mar 25 2015"
    //February 22, 2017 15:30:00
    {
      reg: /^([a-z]+) ([0-9]{1,2})( [0-9]{4})?( ([0-9:]+( ?am| ?pm| ?gmt)?))?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[3]),
          month: parseMonth$1(m[1]),
          date: parseDate$1(m[2] || '')
        };
        obj = parseTime$1(m[4], obj);
        return obj
      }
    },
    // 'Sun Mar 14 15:09:48 +0000 2021'
    {
      reg: /^([a-z]+) ([0-9]{1,2})( [0-9:]+)?( \+[0-9]{4})?( [0-9]{4})?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[5]),
          month: parseMonth$1(m[1]),
          date: parseDate$1(m[2] || '')
        };
        obj = parseTime$1(m[4], obj);
        return obj
      }
    }
  ];

  var dmy = [
    // =====
    //  d-m-y
    // =====
    //common british format - "25-feb-2015"
    {
      reg: /^([0-9]{1,2})[-/]([a-z]+)[-/]?([0-9]{4})?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[3]),
          month: parseMonth$1(m[2]),
          date: parseDate$1(m[1] || '')
        };
        obj = parseTime$1(m[4], obj);
        return obj
      }
    },
    // "25 Mar 2015"
    {
      reg: /^([0-9]{1,2})( [a-z]+)( [0-9]{4}| '[0-9]{2})? ?([0-9]{1,2}:[0-9]{2}:?[0-9]{0,2} ?(am|pm|gmt))?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[3]),
          month: parseMonth$1(m[2]),
          date: parseDate$1(m[1])
        };
        if (!obj.month) {
          return null
        }
        obj = parseTime$1(m[4], obj);
        return obj
      }
    },
    // 01-jan-2020
    {
      reg: /^([0-9]{1,2})[ /]([a-z]+)[ /]([0-9]{4})?( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i,
      parse: (m) => {
        let obj = {
          date: parseDate$1(m[1]),
          month: parseMonth$1(m[2]),
          year: parseYear$1(m[3])
        };
        obj = parseTime$1(m[4], obj);
        return obj
      }
    }
  ];

  var misc$1 = [
    // =====
    // no dates
    // =====

    // '2012-06' month-only
    {
      reg: /^([0-9]{4})[-/]([0-9]{2})$/,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[1]),
          month: parseInt(m[2], 10),
        };
        // s = parseTime(s, m[4])
        return obj
      }
    },

    //February 2017 (implied date)
    {
      reg: /^([a-z]+) ([0-9]{4})$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[2]),
          month: parseMonth$1(m[1]),
        };
        // s = parseTime(s, m[4])
        return obj
      }
    },

    {
      // 'q2 2002'
      reg: /^(q[0-9])( of)?( [0-9]{4})?/i,
      parse: (m) => {
        m[1] || '';
        // TODO: 
        // s = s.quarter(quarter)
        if (m[3]) {
          let year = parseYear$1(m[3]);
          return { year }
        }
        return {}
      }
    },
    {
      // 'summer 2002'
      reg: /^(spring|summer|winter|fall|autumn)( of)?( [0-9]{4})?/i,
      parse: (m) => {
        m[1] || '';
        // TODO: 
        // s = s.season(season)
        if (m[3]) {
          let year = parseYear$1(m[3]);
          return { year }
        }
        return {}
      }
    },
    {
      // '200bc'
      reg: /^[0-9,]+ ?b\.?c\.?$/i,
      parse: (m) => {
        let str = m[0] || '';
        //make year-negative
        str = str.replace(/^([0-9,]+) ?b\.?c\.?$/i, '-$1').trim();
        let obj = {
          year: parseInt(str.trim(), 10),
        };
        return obj
      }
    },
    {
      // '200ad'
      reg: /^[0-9,]+ ?(a\.?d\.?|c\.?e\.?)$/i,
      parse: (m) => {
        let str = m[0] || '';
        //remove commas
        str = str.replace(/,/g, '');
        let obj = {
          year: parseInt(str.trim(), 10),
        };
        // s = parseTime(s)
        return obj
      }
    },
    {
      // '1992'
      reg: /^[0-9]{4}( ?a\.?d\.?)?$/i,
      parse: (m) => {
        // TODO: 
        // let today = s._today
        // using today's date, but a new month is awkward.
        // if (today.month && !today.date) {
        //   today.date = 1
        // }
        let obj = {
          year: parseYear$1(m[0]),
          // month: today.month || d.getMonth(),
          // date: today.date || d.getDate()
        };
        // s = parseTime(s)
        return obj
      }
    }
  ];

  var formats$1 = [].concat(ymd, mdy, dmy, misc$1);

  const parseText = function (txt, tz) {
    let cal = {};
    // normalize it a bit first
    txt = txt.toLowerCase();
    txt = txt.replace(/([0-9])(th|rd|st|nd)\b/, '$1');
    txt = txt.replace(/\b(mon|tues?|wed|wednes|thur?s?|fri|sat|satur|sun)(day)?\b/i, '');
    txt = txt.replace(/,/g, '');
    txt = txt.replace(/ +/g, ' ').trim();
    txt = txt.trim();
    for (let i = 0; i < formats$1.length; i += 1) {
      let m = txt.match(formats$1[i].reg);
      if (m !== null) {
        // console.log(`reg #${i} - ${formats[i].reg}`)
        let res = formats$1[i].parse(m);
        if (res) {
          return res
        }
      }
    }
    return cal
  };
  var parseText$1 = parseText;

  // order for Array input
  const units$1 = ['year', 'month', 'date', 'hour', 'minute', 'second', 'millisecond'];

  const isNumber = val => {
    return typeof val === 'number' && isFinite(val)
  };

  const isObject = val => {
    return Object.prototype.toString.call(val) === '[object Object]'
  };

  const isArray = function (arr) {
    return Object.prototype.toString.call(arr) === '[object Array]'
  };

  const isString = val => {
    return typeof val === 'string'
  };

  const parse = function (input, tz) {
    // reconcile timezone
    tz = findTz$1(tz);

    // null means now
    if (input === null || input === undefined) {
      return { epoch: config.now(), tz }
    }
    // epoch input
    if (isNumber(input)) {
      // if the given epoch is really small, they've probably given seconds and not milliseconds
      if (input < config.minimumEpoch && input > 0) {
        input *= 1000;
      }
      return { epoch: input, tz }
    }
    // support ordered array as input [2020, 04, 1] → {year:2020 ...}
    if (isArray(input)) {
      let cal = units$1.reduce((h, k, i) => {
        h[k] = input[i];
        return h
      }, {});
      if (cal.month) {
        cal.month = parseMonth$1(cal.month);
      }
      return { epoch: getEpoch$1(cal, tz), tz }
    }
    // given {year:2020 ...}
    if (isObject(input)) {
      let cal = Object.assign({}, input);//don't mutate original
      return { epoch: getEpoch$1(cal, tz), tz }
    }
    // pull-apart ISO formats, etc
    if (isString(input)) {
      let cal = parseText$1(input);
      // replace tz with iso timezone
      if (cal.offset !== null && cal.offset !== undefined) {
        if (cal.offset < 0) {
          tz = `Etc/GMT+${Math.abs(cal.offset)}`;
        } else {
          tz = `Etc/GMT-${cal.offset}`;
        }
      }
      return { epoch: getEpoch$1(cal, tz), tz }
    }
    return {}
  };
  var parse$1 = parse;

  let getter$1 = {
    year: (cal) => cal.year,
    month: (cal) => cal.month - 1,//javascript uses 0-based months!
    date: (cal) => cal.date,//1-based dates!
    hour: (cal) => cal.hour,
    minute: (cal) => cal.minute,
    second: (cal) => cal.second,
    day: (cal) => getDay$1(cal.year, cal.month, cal.date),
    ampm: (cal) => cal.hour < 12 ? 'am' : 'pm',
    decade: (cal) => Math.floor(cal.year / 10) * 10,//  eg '1970'
    century: (cal) => Math.floor(cal.year / 100) * 100,//  eg '1900'
    millenium: (cal) => {
      let num = Math.floor(cal.year / 1000);
      return num >= 0 ? num + 1 : num// millenia are 1-based, in AD
    },
    // offset: (cal) => cal.offset * 60,
    era: (cal) => cal.year < 0 ? 'BC' : 'AD',
    quarter: (cal) => {
      let m = cal.month;
      if (m < 3) {
        return 1
      } else if (m < 6) {
        return 2
      } else if (m < 9) {
        return 3
      }
      return 4
    },
    hour12: (cal) => {
      let hour = cal.hour;
      if (hour > 12) {
        return hour - 12
      }
      if (hour === 0) {
        return 12
      }
      return hour
    },
    hourFloat: (cal) => {
      let minute = cal.minute;
      minute = minute / 60;
      return cal.hour + minute
    },
    // dayOfYear: (cal) => {
    //   let sum = cal.date
    //   //count the num days in each month
    //   for (let i = 0; i < cal.month - 1; i++) {
    //     sum += months[i].len
    //     if (i === 1 && isLeapYear(cal.year)) {
    //       sum += 1// feb 29th
    //     }
    //   }
    //   return sum
    // },
    // week: (cal) => {
    //   return null
    // }
  };
  // wednesday/friday
  getter$1.dayName = (cal) => {
    let n = getter$1.day(cal);
    return config.days.longForm[n]
  };
  getter$1.monthName = (cal) => {
    let n = getter$1.month(cal);
    return config.months.longForm[n]
  };

  var getters = getter$1;

  const monthLen = function (n, year) {
    if (n === 2 && isLeap(year)) {
      return 29
    }
    return MONTHS[n - 1].len
  };
  var monthLen$1 = monthLen;

  const mapping$1 = {
    milliseconds: 'millisecond',
    ms: 'millisecond',
    seconds: 'second',
    s: 'second',
    minutes: 'minute',
    min: 'minute',
    mins: 'minute',
    hours: 'hour',
    h: 'hour',
    hr: 'hour',
    dates: 'date',
    day: 'date',
    days: 'date',
    months: 'month',
    years: 'year',
    quarters: 'quarter',
    centuries: 'century',
    millenia: 'millenium',
  };
  const order = [
    'millenium',
    'century',
    'decade',
    'year',
    'quarter',
    'month',
    'week',
    'date',
    'hour',
    'minute',
    'second',
    'millisecond',
  ];
  const isKnown = new Set(order);

  const getUnit = function (input = '') {
    if (typeof input !== 'string') {
      input = String(input);
    }
    input = input.toLowerCase().trim();
    if (mapping$1.hasOwnProperty(input)) {
      input = mapping$1[input];
    }
    if (isKnown.has(input)) {
      return input
    }
    console.error(`Unknown unit: '${input}'`);
    return null
  };

  let assumed = {
    month: 1, //co-erce any zeros to 1s
    date: 1, // (same)
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  };

  const rollDays = function (cal) {
    let len = monthLen$1(cal.month, cal.year);
    while (cal.date > len) {
      cal.date -= len;
      cal.month += 1;
      if (cal.month > 12) {
        cal.year += Math.floor(cal.month / 12);
        cal.month = cal.month % 12;
      }
      len = monthLen$1(cal.month, cal.year);
    }
    return cal
  };

  const rollFwd = function (cal) {
    // if (cal.millisecond > 999) {
    //   cal.second += Math.floor(cal.millisecond / 1000)
    //   cal.millisecond = cal.millisecond % 1000
    // }
    // // second
    // if (cal.second > 59) {
    //   cal.minute += Math.floor(cal.second / 60)
    //   cal.second = cal.second % 60
    // }
    // // minute
    // if (cal.minute > 59) {
    //   cal.hour += Math.floor(cal.minute / 60)
    //   cal.minute = cal.minute % 60
    // }
    // hour (1-based)
    // if (cal.hour > 24) {
    //   cal.date += Math.floor(cal.hour / 24)
    //   cal.hour = cal.hour % 24
    // }
    // resolve the month, first
    if (cal.month > 12) {
      cal.year += Math.floor(cal.month / 12);
      cal.month = cal.month % 12;
    }
    // now we can do the date+month
    let len = monthLen$1(cal.month, cal.year);
    if (cal.date > len) {
      cal = rollDays(cal);
    }
    return cal
  };

  const rollBkwd = function (cal) {
    // fix negative months
    while (cal.month < 1) {
      cal.year -= 1;
      cal.month += 12;
    }
    while (cal.date < 1) {
      cal.month -= 1;
      if (cal.month < 1) {
        cal.year -= 1;
        cal.month += 12;
      }
      let len = monthLen$1(cal.month, cal.year);
      cal.date += len;
    }
    // return cal
    return cal
  };

  // do a calendar-walk
  const walk = function (cal, n, unit) {
    cal = Object.assign({}, assumed, cal);
    unit = getUnit(unit);
    cal[unit] += n;
    // roll backward
    cal = rollBkwd(cal);
    // roll forward
    cal = rollFwd(cal);
    return cal
  };
  var tickBy = walk;

  // console.log(walk({ year: 2019, month: 4, date: 4 }))

  // import startOf from './startOf.js'

  let fns = {
    year: (input, cal) => {
      cal.year = parseYear$1(input);
      return cal
    },
    month: (input, cal) => {
      cal.month = parseMonth$1(input);
      return cal
    },
    date: (input, cal) => {
      cal.date = parseDate$1(input);
      return cal
    },
    hour: (input, cal) => {
      cal.hour = parseHour$1(input);
      return cal
    },
    minute: (input, cal) => {
      cal.minute = Number(input);
      return cal
    },
    second: (input, cal) => {
      cal.second = Number(input);
      return cal
    },
    time: (input, cal) => {
      return Object.assign(cal, parseTime$1(input))
    },
    hourFloat: (input, cal) => {
      input = Number(input);
      cal.hour = Math.floor(input);
      cal.minute = Math.floor((input % 1) * 60);// (0.25 -> 15)
      return cal
    },
    quarter: (input, cal) => {
      cal = Object.assign(cal, { date: 1, hour: 0, minute: 0, second: 0, millisecond: 0 });
      if (input === 1) {
        cal.month = 1;//jan 1
      } else if (input === 2) {
        cal.month = 3;//apr 1
      } else if (input === 3) {
        cal.month = 6;//july 1
      } else if (input === 4) {
        cal.month = 9;//oct 1
      }
      cal.date = 1;
      return cal
    },
    ampm: (input, cal) => {
      let h = cal.hour;
      let val = parseAmpm(input);
      if (val === 'am') {
        h = h > 12 ? h - 12 : h;
      } else if (val === 'pm') {
        h = h < 12 ? h + 12 : h;
      }
      cal.hour = h;
      return cal
    },
    era: (input, cal) => {
      input = input.toLowerCase().replace(/\./g, '').trim();
      if (input === 'bc' && cal.year > 0) {
        cal.year *= -1;
      }
      return cal
    },

    // dayOfYear: function (input) {
    //   let s = this.startOf('year')
    //   return s.add(input, 'day')
    // },

    // decade: (cal) => Math.floor(cal.year / 10) * 10,//  eg '1970'
    // century: (cal) => Math.floor(cal.year / 100) * 100,//  eg '1900'
    // millenium: (cal) => {
    //   let num = Math.floor(cal.year / 1000)
    //   return num >= 0 ? num + 1 : num// millenia are 1-based, in AD
    // },
    // eg '1970'
    decade: function (input, cal) {
      let r = cal.year % 10;
      cal.year = Number(input) + r;
      return cal
    },
    // eg '1900'
    century: function (input, cal) {
      let r = cal.year % 100;
      cal.year = Number(input) + r;
      return cal
    },
    // eg 1
    millenium: function (input, cal) {
      let r = cal.year % 1000;
      let m = Number(input) - 1;
      cal.year = (m * 1000) + r;
      return cal
    },

    // this one is tricky!
    day: function (n, cal, _tz, fwd) {
      let day = getDay$1(cal.year, cal.month, cal.date);
      if (day === n) {
        return cal
      }
      let diff = n - day;
      // go in a specific direction
      if (diff < 0 && fwd === true) {
        diff = 7 + diff;
      } else if (diff > 0 && fwd === false) {
        diff = diff - 7;
      }
      return tickBy(cal, diff, 'date')
    },

  };
  fns.monthName = fns.month;
  fns.dayName = fns.day;
  fns.hour12 = fns.hour;
  var setters = fns;

  const monthLengths = MONTHS.map(o => o.len);

  const getDate = function (diffDays, year) {
    let res = { month: 1, date: 1 };
    let total = 0;
    for (let i = 0; i < MONTHS.length - 1; i += 1) {
      let inMonth = monthLengths[i];
      if (i === 1 && isLeap(year)) {
        inMonth = 29;
      }
      if (total + inMonth > diffDays) {
        break
      }
      total += inMonth;
      res.month += 1;
    }
    // add remainder to days
    res.date += diffDays - total;
    return res
  };

  const getTime = function (ms) {
    let res = { hour: 0, minute: 0, second: 0, millisecond: 0 };
    // get hour
    res.hour = Math.floor(ms / HOUR);
    ms -= res.hour * HOUR;
    // get minute
    res.minute = Math.floor(ms / MINUTE);
    ms -= res.minute * MINUTE;
    // get second
    res.second = Math.floor(ms / SECOND);
    ms -= res.second * SECOND;
    // remainder milliseconds
    res.millisecond = ms;
    return res
  };

  // take an epoch, return {month, year, date...}
  const computeCal = function (epoch, tz) {
    // get Jan 1 of the year
    let { start, year } = getYear(epoch, tz);
    let zone = zones$2[tz] || {};
    let cal = {
      year,
      month: 1,
      date: 1,
      hour: 0,
      second: 0,
      millisecond: 0,
      offset: zone.offset || 0
    };
    // kick the epoch around, according to our DST offset
    let changes = getDst$1(tz, year);
    if (zone.hem === 's') {
      // southern hemisphere
      for (let i = 0; i < changes.length; i += 1) {
        if (epoch < changes[i].epoch) {
          cal.offset = changes[i].offset;
          epoch -= changes[i].delta * HOUR;
          break
        }
      }
      cal.offset += 1;
    } else {
      // northern hemisphere
      for (let i = changes.length - 1; i >= 0; i -= 1) {
        if (epoch >= changes[i].epoch) {
          cal.offset = changes[i].offset;
          epoch += changes[i].delta * HOUR;
          break
        }
      }
    }
    // walk the days
    let diff = epoch - start;
    let daysDiff = Math.floor(diff / DAY);
    // compute month, date
    let resDate = getDate(daysDiff, year);
    Object.assign(cal, resDate);

    // compute hour, min, sec..
    let deltaMs = diff - (daysDiff * DAY);
    let resMins = getTime(deltaMs);
    Object.assign(cal, resMins);
    return cal
  };
  var getCal = computeCal;

  function titleCase(str) {
    if (!str) {
      return ''
    }
    return str[0].toUpperCase() + str.substr(1)
  }

  function ordinal(i) {
    let j = i % 10;
    let k = i % 100;
    if (j === 1 && k !== 11) {
      return i + 'st'
    }
    if (j === 2 && k !== 12) {
      return i + 'nd'
    }
    if (j === 3 && k !== 13) {
      return i + 'rd'
    }
    return i + 'th'
  }

  function zeroPad(str, len = 2) {
    let pad = '0';
    str = str + '';
    return str.length >= len ? str : new Array(len - str.length + 1).join(pad) + str
  }

  let { days, months } = config;

  const fmt = {

    day: (c) => titleCase(getters.dayName(c)),
    'day-short': (c) => titleCase(days.shortForm[getters.day(c)]),
    'day-number': (c) => getters.day(c),
    'day-ordinal': (c) => ordinal(getters.day(c)),
    'day-pad': (c) => zeroPad(getters.day(c)),

    date: (c) => c.date,
    'date-ordinal': (c) => ordinal(c.date),
    'date-pad': (c) => zeroPad(c.date),

    month: (c) => titleCase(getters.monthName(c)),
    'month-short': (c) => titleCase(months.shortForm[c.month - 1]),
    'month-number': (c) => c.month,
    'month-ordinal': (c) => ordinal(c.month),
    'month-pad': (c) => zeroPad(c.month),
    'iso-month': (c) => zeroPad(c.month + 1), //1-based months

    year: (c) => c.year > 0 ? c.year : `${Math.abs(c.year)} BC`,
    'year-short': (c) => c.year > 0 ? `'${String(c.year).substring(2, 4)}` : Math.abs(c.year) + ' BC',
    'iso-year': (c) => {
      let str = zeroPad(Math.abs(c.year), 4); //0-padded
      if (c.year < 0) {
        str = '-' + zeroPad(str, 6);  //negative years are for some reason 6-digits ('-00008')
      }
      return str
    },

    time: (c) => `${getters.hour12(c)}:${zeroPad(c.minute)}${getters.ampm(c)}`,
    'time-24': (c) => `${zeroPad(c.hour)}:${zeroPad(c.minute)}`,

    hour: (c) => getters.hour12(c),
    'hour-pad': (c) => zeroPad(getters.hour12(c)),
    'hour-24': (c) => c.hour,
    'hour-24-pad': (c) => zeroPad(c.hour),

    minute: (c) => c.minute,
    'minute-pad': (c) => zeroPad(c.minute),
    second: (c) => c.second,
    'second-pad': (c) => zeroPad(c.second),
    ms: (c) => c.millisecond,
    millisecond: (c) => c.millisecond,
    'millisecond-pad': (c) => zeroPad(c.millisecond, 3),

    ampm: (c) => getters.ampm(c),
    AMPM: (c) => getters.ampm(c).toUpperCase(),
    quarter: (c) => 'Q' + getters.quarter(c),

    // turn timezone 5.25 into '+05:15'
    offset: (c) => {
      let n = c.offset || 0;
      if (n === 0) {
        return 'Z'
      }
      let out = n <= 0 ? '-' : '+';
      n = Math.abs(n);
      // add hour
      let h = parseInt(n, 10);
      out += String(h).padStart(2, '0');
      // add minute
      let decimal = n % 1;
      if (decimal) {
        let min = decimal * 60;
        out += ':' + String(min).padStart(2, '0');
      } else {
        out += ':00';
      }
      return out
    }
  };
  // compound ones
  fmt['iso-short'] = (c) => `${fmt['iso-year'](c)}-${zeroPad(c.month)}-${zeroPad(c.date)}`;
  fmt['iso-medium'] = (c) => `${fmt['iso-short'](c)}T${zeroPad(c.hour)}:${zeroPad(c.minute)}:${zeroPad(c.second)}.${zeroPad(c.millisecond, 3)}`;
  fmt['iso'] = (c) => `${fmt['iso-medium'](c)}${fmt.offset(c)}`;
  //i made these up
  fmt['nice'] = (c) => `${fmt['month-short'](c)} ${fmt['date-ordinal'](c)}, ${fmt['time'](c)}`;
  fmt['nice-day'] = (c) => `${fmt['day-short'](c)} ${fmt['month-short'](c)} ${fmt['date-ordinal'](c)}`;


  // aliases
  const aliases$1 = {
    'hour-12': 'hour',
    'hour-12-pad': 'hour-pad',
    'day-name': 'day',
    'month-name': 'month',
    'iso 8601': 'iso',
    'time-h24': 'time-24',
    'time-12': 'time',
    'time-h12': 'time',
    tz: 'timezone',
    'day-num': 'day-number',
    'month-num': 'month-number',
    'month-iso': 'iso-month',
    'year-iso': 'iso-year',
    'nice-short': 'nice',
    'nice-short-24': 'nice-24',
    mdy: 'numeric-us',
    dmy: 'numeric-uk',
    ymd: 'numeric',
    'yyyy/mm/dd': 'numeric',
    'mm/dd/yyyy': 'numeric-us',
    'dd/mm/yyyy': 'numeric-us',
    'little-endian': 'numeric-uk',
    'big-endian': 'numeric',
    'day-nice': 'nice-day',
    // 'nice-day': '{day-short} {month-short} {date-ordinal}'
  };
  Object.keys(aliases$1).forEach((k) => (fmt[k] = fmt[aliases$1[k]]));

  var formats = fmt;

  const replace = function (cal, str) {
    let sections = /\{(.+?)\}/g;
    str = str.replace(sections, (_, name) => {
      name = name.toLowerCase().trim();
      if (formats.hasOwnProperty(name)) {
        return formats[name](cal)
      }
      return `{${name}}`
    });
    return str
  };
  var replace$1 = replace;

  // import { formatTimezone } from '../../fns.js'
  //parse this insane unix-time-templating thing, from the 19th century
  //http://unicode.org/reports/tr35/tr35-25.html#Date_Format_Patterns

  //time-symbols we support
  const mapping = {
    G: (c) => getters.era(c),
    GG: (c) => getters.era(c),
    GGG: (c) => getters.era(c),
    GGGG: (c) => (getters.era(c) === 'AD' ? 'Anno Domini' : 'Before Christ'),
    //year
    y: (c) => c.year,
    yy: (c) => zeroPad(Number(String(c.year).substring(2, 4))), //last two chars
    yyy: (c) => c.year,
    yyyy: (c) => c.year,
    yyyyy: (c) => '0' + c.year,
    // u: (c) => {},//extended non-gregorian years

    //quarter
    Q: (c) => getters.quarter(c),
    QQ: (c) => getters.quarter(c),
    QQQ: (c) => getters.quarter(c),
    QQQQ: (c) => getters.quarter(c),

    //month
    M: (c) => c.month,
    MM: (c) => zeroPad(c.month),
    MMM: (c) => formats['month-short'](c),
    MMMM: (c) => titleCase(getters.monthName(c)),

    //week
    w: (c) => getters.week(c),
    ww: (c) => zeroPad(getters.week(c)),
    //week of month
    // W: (c) => s.week(),

    //date of month
    d: (c) => c.date,
    dd: (c) => zeroPad(c.date),
    //date of year
    D: (c) => getters.dayOfYear(c),
    DD: (c) => zeroPad(getters.dayOfYear(c)),
    DDD: (c) => zeroPad(getters.dayOfYear(c), 3),

    // F: (c) => {},//date of week in month
    // g: (c) => {},//modified julian day

    //day
    E: (c) => formats['day-short'](c),
    EE: (c) => formats['day-short'](c),
    EEE: (c) => formats['day-short'](c),
    EEEE: (c) => formats['day'](c),
    EEEEE: (c) => formats['day'](c)[0],
    e: (c) => formats['day'](c),
    ee: (c) => formats['day'](c),
    eee: (c) => formats['day-short'](c),
    eeee: (c) => formats['day'](c),
    eeeee: (c) => formats['day'](c)[0],

    //am/pm
    a: (c) => getters.ampm(c).toUpperCase(),
    aa: (c) => getters.ampm(c).toUpperCase(),
    aaa: (c) => getters.ampm(c).toUpperCase(),
    aaaa: (c) => getters.ampm(c).toUpperCase(),

    //hour
    h: (c) => getters.hour12(c),
    hh: (c) => zeroPad(getters.hour12(c)),
    H: (c) => c.hour,
    HH: (c) => zeroPad(c.hour),
    // j: (c) => {},//weird hour format

    m: (c) => c.minute,
    mm: (c) => zeroPad(c.minute),
    s: (c) => c.second,
    ss: (c) => zeroPad(c.second),

    //milliseconds
    SSS: (c) => zeroPad(c.millisecond, 3),
    //milliseconds into the day
    A: (c) => {
      let morn = Object.assign({}, c, { hour: 0, minute: 0, second: 0, millisecond: 0 });
      return getEpoch$1(c) - getEpoch$1(morn)
    },
    //timezone
    z: (_, tz) => tz,
    zz: (_, tz) => tz,
    zzz: (_, tz) => tz,
    zzzz: (_, tz) => tz,
    Z: (c) => formats.offset(c).replace(/:/, ''),
    ZZ: (c) => formats.offset(c).replace(/:/, ''),
    ZZZ: (c) => formats.offset(c).replace(/:/, ''),
    ZZZZ: (c) => formats.offset(c)
  };

  const addAlias = (char, to, n) => {
    let name = char;
    let toName = to;
    for (let i = 0; i < n; i += 1) {
      mapping[name] = mapping[toName];
      name += char;
      toName += to;
    }
  };
  addAlias('q', 'Q', 4);
  addAlias('L', 'M', 4);
  addAlias('Y', 'y', 4);
  addAlias('c', 'e', 4);
  addAlias('k', 'H', 2);
  addAlias('K', 'h', 2);
  addAlias('S', 's', 2);
  addAlias('v', 'z', 4);
  addAlias('V', 'Z', 4);

  // support unix-style escaping with ' character
  const escapeChars = function (arr) {
    for (let i = 0; i < arr.length; i += 1) {
      if (arr[i] === `'`) {
        // greedy-search for next apostrophe
        for (let o = i + 1; o < arr.length; o += 1) {
          if (arr[o]) {
            arr[i] += arr[o];
          }
          if (arr[o] === `'`) {
            arr[o] = null;
            break
          }
          arr[o] = null;
        }
      }
    }
    return arr.filter((ch) => ch)
  };

  //combine consecutive chars, like 'yyyy' as one.
  const combineRepeated = function (arr) {
    for (let i = 0; i < arr.length; i += 1) {
      let c = arr[i];
      // greedy-forward
      for (let o = i + 1; o < arr.length; o += 1) {
        if (arr[o] === c) {
          arr[i] += arr[o];
          arr[o] = null;
        } else {
          break
        }
      }
    }
    // '' means one apostrophe
    arr = arr.filter((ch) => ch);
    arr = arr.map((str) => {
      if (str === `''`) {
        str = `'`;
      }
      return str
    });
    return arr
  };

  const unixFmt = (cal, str, tz) => {
    let arr = str.split('');
    // support character escaping
    arr = escapeChars(arr);
    //combine 'yyyy' as string.
    arr = combineRepeated(arr);
    return arr.reduce((txt, c) => {
      if (mapping[c] !== undefined) {
        txt += mapping[c](cal, tz) || '';
      } else {
        // 'unescape'
        if (/^'.+'$/.test(c)) {
          c = c.replace(/'/g, '');
        }
        txt += c;
      }
      return txt
    }, '')
  };
  var unixFmt$1 = unixFmt;

  let methods$2 = {
    format: function (fmt = 'iso-short') {
      let cal = getCal(this.epoch, this.tz);
      if (fmt && formats.hasOwnProperty(fmt)) {
        return formats[fmt](cal)
      }
      return replace$1(cal, fmt)
    },
    unixFmt: function (fmt) {
      let cal = getCal(this.epoch, this.tz);
      return unixFmt$1(cal, fmt, this.tz)
    }
  };

  // add extra wrappers for format methods
  let diriv = ['iso'];
  diriv.forEach(fn => {
    methods$2[fn] = function () {
      let cal = getCal(this.epoch, this.tz);
      return formats[fn](cal)
    };
  });

  var fmts = methods$2;

  const slideUnits = {
    ms: 1,
    milli: 1,
    millis: 1,
    millisecond: 1,
    milliseconds: 1,
    second: SECOND,
    seconds: SECOND,
    minute: MINUTE,
    minutes: MINUTE,
    h: HOUR,
    hs: HOUR,
    hour: HOUR,
    hours: HOUR,
    'quarterhour': MINUTE * 15,
    'quarter-hour': MINUTE * 15,
    'quarter-hours': MINUTE * 15,
  };


  var add$1 = {

    add: function (n, unit) {
      let { epoch, tz } = this;
      // let epoch = add(this.epoch, n, unit)
      if (n === 0 || !unit) {
        return this._from(epoch, tz)
      }
      unit = unit.trim().toLowerCase();
      // millisecond-math for these units
      if (slideUnits.hasOwnProperty(unit)) {
        let ms = slideUnits[unit];      // how many milliseconds are we adding?
        epoch += ms * n;
        return this._from(epoch, tz)
      }
      // misc units
      if (unit === 'week' || unit === 'weeks') {
        n *= 7;
        unit = 'day';
      }
      if (unit === 'quarter' || unit === 'quarters') {
        n *= 3;
        unit = 'month';
      }
      if (unit === 'decade' || unit === 'decades') {
        n *= 10;
        unit = 'year';
      }
      if (unit === 'century' || unit === 'centuries') {
        n *= 100;
        unit = 'year';
      }
      // add a 'tick' unit
      let cal = getCal(epoch, tz);
      cal = tickBy(cal, n, unit);
      epoch = getEpoch$1(cal, tz);
      return this._from(epoch, tz)
    },

    subtract: function (n, unit) {
      return this.add(n * -1, unit)
    },
  };

  //make a string, for easy comparison between dates
  const print = {
    millisecond: (s) => s.epoch,
    second: (s) => [print.minute(s), s.second()].join('-'),
    minute: (s) => [print.hour(s), s.minute()].join('-'),
    hour: (s) => [print.date(s), s.hour()].join('-'),
    date: (s) => [print.month(s), s.date()].join('-'),
    month: (s) => [print.year(s), s.month()].join('-'),
    year: (s) => s.year(),
    // misc ones
    week: (s) => [s.year(), s.week()].join('-'),
    quarter: (s) => [s.year(), s.quarter()].join('-'),
    season: (s) => [s.year(), s.season()].join('-'),
    decade: (s) => s.decade(),
    century: (s) => s.century(),
  };

  var compare = {
    isSame: function (b, unit) {
      unit = getUnit(unit);
      b = this._from(b);
      return print[unit](this) === print[unit](b)
    },
    isBefore: function (b) {
      b = this._from(b);
      return this.epoch < b.epoch
    },
    isAfter: function (b) {
      b = this._from(b);
      return this.epoch > b.epoch
    },
    isEqual: function (b) {
      b = this._from(b);
      return this.epoch === b.epoch
    },
    isBetween: function (start, end, isInclusive = false) {
      start = this._from(start);
      end = this._from(end);
      let inside = this.epoch > start.epoch && this.epoch < end.epoch;
      if (!inside && isInclusive) {
        return this.epoch === start.epoch || this.epoch === end.epoch
      }
      return inside
    },
    every: function (unit, end) {
      unit = getUnit(unit);
      end = this._from(end);
      let result = [];
      let d = this.clone();
      while (d.isBefore(end)) {
        result.push(d);
        d = d.add(1, unit);
      }
      return result
    },
    // round up or down on this unit
    nearest: function (unit) {
      unit = getUnit(unit);
      let before = this.startOf(unit);
      let next = this.next(unit);
      let diffDown = this.epoch - before.epoch;
      let diffUp = Math.abs(this.epoch - next.epoch);
      if (diffUp > diffDown) {
        return before// go up
      }
      return next
    },

  };

  //increment until dates are the same
  const climb = (a, b, unit) => {
    // do fast-mode for these units
    if (unit === 'milliseconds') {
      return b.epoch - a.epoch
    }
    if (unit === 'seconds') {
      return Math.floor((b.epoch - a.epoch) / 1000)
    }
    if (unit === 'minutes') {
      return Math.floor((b.epoch - a.epoch) / (1000 * 60))
    }

    // slow-mode for these units
    let n = 0;
    while (a.isBefore(b)) {
      //do proper, expensive increment to catch all-the-tricks
      a = a.add(1, unit);
      n += 1;
    }
    //oops, we went too-far..
    if (a.isAfter(b, unit)) {
      n -= 1;
    }
    return n
  };

  // do a thurough +=1 on the unit, until they match
  // for speed-reasons, only used on day, month, week.
  const diffOne = (a, b, unit) => {
    if (a.isBefore(b)) {
      return climb(a, b, unit)
    } else {
      return climb(b, a, unit) * -1 //reverse it
    }
  };

  var diffOne$1 = diffOne;

  // import waterfall from './waterfall.js'

  const units = [
    'milliseconds',
    'seconds',
    'minutes',
    'hours',
    'days',
    'months',
    'years',
    // 'quarters',
    // 'weeks',
  ];

  var diff = {
    // 
    diff: function (b, unit) {
      b = this._from(b);
      if (unit) {
        unit = getUnit(unit);
        return diffOne$1(this, b, unit)
      }
      return units.reduce((h, u) => {
        h[u] = diffOne$1(this, b, u);
        return h
      }, {})
    },
    since: function (b, unit) {
      // unit = getUnit(unit)
      return {}
    }
  };

  const add = (a, b) => Object.assign({}, a, b);

  // which zeros to cascade, for 'start of hour', etc.
  let z = { millisecond: {} };
  z.second = add(z.millisecond, { millisecond: 0 });
  z.minute = add(z.second, { second: 0 });
  z.hour = add(z.minute, { minute: 0 });
  z.date = add(z.hour, { hour: 0 });
  z.month = add(z.date, { date: 1 });
  z.year = add(z.month, { month: 1 });

  const roundYear = (c, by) => {
    c.year = Math.floor(c.year / by) * by;
    return c
  };

  const startMisc = {
    quarterHour: (c) => {
      let m = c.minute;
      if (m >= 45) {
        c.minute = 45;
      } else if (m >= 30) {
        c.minute = 30;
      } else if (m >= 15) {
        c.minute = 15;
      } else {
        c.minute = 0;
      }
      return Object.assign(c, { millisecond: 0, second: 0 })
    },
    decade: (c) => roundYear(c, 10),
    century: (c) => roundYear(c, 100),
    millenium: (c) => roundYear(c, 1000)
  };

  var startOf = {
    startOf: function (unit) {
      unit = getUnit(unit);
      let cal = getCal(this.epoch, this.tz);
      if (z.hasOwnProperty(unit)) {
        cal = Object.assign(cal, z[unit]);
      } else if (startMisc.hasOwnProperty(unit)) {
        cal = startMisc[unit](cal);
      }
      // this one is tricky
      if (unit === 'week') {
        let s = this.day(config.weekStart);
        s = s.startOf('day');
        cal = getCal(s.epoch, s.tz);
      }
      let epoch = getEpoch$1(cal, this.tz);
      return this._from(epoch)
    },
    next: function (unit) {
      unit = getUnit(unit);
      let s = this.startOf(unit);
      return s.add(1, unit)
    },
    last: function (unit) {
      unit = getUnit(unit);
      let s = this.startOf(unit);
      return s.minus(1, unit)
    },
    endOf: function (unit) {
      unit = getUnit(unit);
      let s = this.next(unit);  // go to next one, step back 1ms
      s = s.subtract(1, 'millisecond');
      return s
    }
  };

  const getter = {
    week: (s) => {
      let start = s.startOf('year').startOf('week');
      return start.diff(s, 'week')
    },
    dayOfYear: (s) => {
      let start = s.startOf('year');
      return start.diff(s, 'day')
    }
  };

  const setter = {
    week: (s, input) => {
      let d = s.startOf('year').startOf('week');
      return d.add(input, 'week')
    },
    dayOfYear: (s, input) => {
      let d = s.startOf('year');
      return d.add(input, 'day')
    }
  };

  var misc = {
    week: function (input) {
      if (input !== undefined) {
        return setter.week(this, input)
      }
      return getter.week(this)
    },

    dayOfYear: function (input) {
      if (input !== undefined) {
        return setter.dayOfYear(this, input)
      }
      return getter.dayOfYear(this)
    },
    daysInMonth: function () {
      return monthLen$1(this.month() + 1, this.year())
    },
    isLeapYear: function () {
      return isLeap(this.year())
    },
    timezone: function () {
      return {
        name: this.tz,
        // hasDst: true,
        // default_offset: -4,
        // hemisphere: 'North',
        // current: { offset: -5, isDST: false },
        // change: { start: '03/12:02', back: '11/05:02' }
      }
    }
  };

  let methods = {};

  // generate all getter/setter function pairs
  Object.keys(getters).forEach(fn => {
    if (!setters[fn]) {
      console.error('no-setter:', fn);
    }
    methods[fn] = function (input, dir) {
      let { epoch, tz } = this;
      let cal = getCal(epoch, tz);
      // setter method
      if (input !== undefined) {
        let c = setters[fn](input, cal, tz, dir);
        let e = getEpoch$1(c, tz);
        return this._from(e, tz)
      }
      // getter method
      return getters[fn](cal, tz)
    };
  });

  // add format methods
  Object.assign(methods, fmts, add$1, compare, startOf, misc, diff);

  methods.time = function (input) {
    if (input !== undefined) {
      let { epoch, tz } = this;
      let cal = getCal(epoch, tz);
      let c = setters.time(input, cal, tz);
      let e = getEpoch$1(c, tz);
      return this._from(e, tz)
    }
    return this.format('time')
  };

  methods.clone = function () {
    return this._from(this.epoch, this.tz)
  };

  methods.json = function () {
    let { epoch, tz } = this;
    let out = getCal(epoch, tz);
    out.epoch = epoch;
    out.tz = tz;
    let z = zones$2[tz] || {};
    out.hem = z.hem;
    out.abbrevs = z.shrt;
    out.dst = getDst$1(tz, out.year);
    return out
  };
  // aliases
  methods.fmt = methods.format;
  methods.text = methods.format;
  methods.leapYear = methods.isLeapYear;
  methods.isLeap = methods.isLeapYear;

  var methods$1 = methods;

  class SpaceTime {
    constructor(input, tz) {
      let res = parse$1(input, tz);
      //the holy UNIX moment
      this._epoch = res.epoch;
      //the IANA code for the current timezone
      this.tz = res.tz;
      this.isSpacetime = true;
    }
    get epoch() {
      return this._epoch
    }
  }

  // const SpaceTime = function (input, tz) {
  //   let res = parse(input, tz)
  //   //the holy UNIX moment
  //   this.epoch = res.epoch
  //   //the IANA code for the current timezone
  //   this.tz = res.tz
  //   this.isSpacetime = true
  // }

  // // builder/factory
  SpaceTime.prototype._from = function (input, tz) {
    if (input && input.isSpacetime === true) {
      return input.clone()
    }
    return new SpaceTime(input, tz || this.tz)
  };
  Object.assign(SpaceTime.prototype, methods$1);

  // add method aliases
  const aliases = [
    ['hours', 'hour'],
    ['minutes', 'minute'],
    ['seconds', 'second'],
    ['minus', 'subtract'],
    ['plus', 'add'],
  ];
  aliases.forEach(a => {
    SpaceTime.prototype[a[0]] = SpaceTime.prototype[a[1]];
  });


  var Spacetime = SpaceTime;

  var version = '7.4.0';

  const main = (input, tz) => new Spacetime(input, tz);

  //some helper functions on the main method
  main.now = (tz) => new Spacetime(config.now(), tz);

  main.today = (tz) => new Spacetime(new Date().getTime(), tz).startOf('day');
  main.tomorrow = (tz) => main.today(tz).add(1, 'day');
  main.yesterday = (tz) => main.today(tz).minus(1, 'day');

  main.plugin = function (plg) {
    if (plg.api) {
      Object.assign(Spacetime.prototype, plg.api);
    }
  };
  main.version = version;

  return main;

}));
