/* spencermountain/spacetime 7.4.0 Apache 2.0 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.spacetime = factory());
})(this, (function () { 'use strict';

  var world = {
    methods: {
      // this should be the only Date call, anywhere
      now: () => new Date().getTime(),
      // stub for proper input parsing
      parse: (input) => input
    },
    model: {},
    config: {},
    zones: {}
  };

  // import parse from './01-one/methods/parse/index.js'


  class SpaceTime {
    constructor(input, tz) {
      // define data
      Object.defineProperty(this, 'world', { value: world });
      const { methods } = world;
      // reconcile timezone
      tz = methods.parseTz(tz, world);
      // generate an epoch, when possible
      let res = methods.parse(input, tz, world);
      //the holy UNIX moment
      this._epoch = res.epoch;
      //the IANA code for the current timezone
      this.tz = res.tz || methods.fallbackTz(world);
      // this is handy, too
      Object.defineProperty(this, 'isSpacetime', { value: true });
    }

    get epoch() {
      // is it playing?
      if (this.isRunning && this.startEpoch !== null) {
        let ms = this.methods.now() - this.startEpoch;
        return this._epoch + ms
      }
      return this._epoch
    }
  }

  // builder/factory
  SpaceTime.prototype._from = function (input, tz) {
    let s = new SpaceTime(input, tz || this.tz);
    return s
  };
  SpaceTime.prototype.set = function (input, tz) {
    const { methods } = world;
    // reconcile timezone
    tz = methods.parseTz(tz, world);
    // generate an epoch, when possible
    let res = methods.parse(input, tz, world);
    return this._from(res.epoch, res.tz)
  };
  // Object.assign(SpaceTime.prototype, api)




  var Spacetime = SpaceTime;

  var version = '7.4.0';

  const lib = (input, tz) => new Spacetime(input, tz);
  // lib.world = () => world


  Object.defineProperty(lib, 'world', { value: world });

  lib.plugin = function (plg) {
    Object.assign(lib.world.zones, plg.zones || {});
    Object.assign(lib.world.config, plg.config || {});
    Object.assign(lib.world.model, plg.model || {});
    Object.assign(Spacetime.prototype, plg.api || {});
    Object.assign(lib.world.methods, plg.methods || {});
  };
  lib.version = version;

  //some helper functions on the main method
  lib.now = (tz) => new Spacetime(null, tz);
  lib.today = (tz) => lib.now(tz).startOf('day');
  lib.tomorrow = (tz) => lib.today(tz).add(1, 'day');
  lib.yesterday = (tz) => lib.today(tz).minus(1, 'day');
  lib.zones = function () {
    return this.world.zones
  };

  var lib$1 = lib;

  const SECOND = 1000;
  const MINUTE = 60 * SECOND;
  const HOUR = 60 * MINUTE;
  const DAY = 24 * HOUR;
  const YEAR = 365 * DAY; // (non-leap)

  var model = {
    months: [
      null,//1-based months
      { longForm: 'January', shortForm: 'Jan', len: 31 },
      { longForm: 'February', shortForm: 'Feb', len: 28 }, // 29 in a leap year
      { longForm: 'March', shortForm: 'Mar', len: 31 },
      { longForm: 'April', shortForm: 'Apr', len: 30 },
      { longForm: 'May', shortForm: 'May', len: 31 },
      { longForm: 'June', shortForm: 'Jun', len: 30 },
      { longForm: 'July', shortForm: 'Jul', len: 31 },
      { longForm: 'August', shortForm: 'Aug', len: 31 },
      { longForm: 'September', shortForm: 'Sep', len: 30 },
      { longForm: 'October', shortForm: 'Oct', len: 31 },
      { longForm: 'November', shortForm: 'Nov', len: 30 },
      { longForm: 'December', shortForm: 'Dec', len: 31 },
    ],

    days: [
      { longForm: 'Sunday', shortForm: 'Sun' },
      { longForm: 'Monday', shortForm: 'Mon' },
      { longForm: 'Tuesday', shortForm: 'Tue' },
      { longForm: 'Wednesday', shortForm: 'Wed' },
      { longForm: 'Thursday', shortForm: 'Thu' },
      { longForm: 'Friday', shortForm: 'Fri' },
      { longForm: 'Saturday', shortForm: 'Sat' }
    ],

    time: {
      am: 'am',
      pm: 'pm'
    },

    ms: {
      SECOND, MINUTE, HOUR, DAY, YEAR
    },

    // units: {
    //   second: [1, 'second'],
    //   decade: [10, 'year'],
    // }
  };

  var config$1 = {

    // should spacetime crash when it gets an unparsable date?
    throwUnparsedDate: true,

    // should spacetime crash when it gets an unknown timezone?
    throwUnknownTz: true,

    // local timezone
    tryLocalTimezone: true,

    // if Intl.DateTimeFormat is not supported - fallback to UTC
    fallbackTz: 'Etc/Utc',


    // automatically in .format()
    useTitleCase: true,

    //default is Monday
    weekStart: 1,


    // assume the british interpretation of 02/02/2018, etc
    preferDMY: false,
  };

  // ===  spacetime /one doesn't have timezones ==
  // but we can shim-in these Etc ones, which work okay

  let zones$3 = { 'Etc/GMT': { offset: 0, hem: 'n' } };

  // generate these sorta-fake timezones 
  for (let i = -14; i <= 14; i += 0.5) {
    let num = i;
    if (num > 0) {
      num = '+' + num;
    }
    // Etc/GMT-5
    let name = 'Etc/GMT' + num;
    zones$3[name] = {
      offset: i * -1, //they're negative!
      hem: 'n' //(sorry)
    };
    let alias = 'UTC/GMT' + num; //this one too, why not.
    zones$3[alias] = zones$3[name];
  }
  // these appear sometimes
  zones$3['Etc/GMT+0'] = zones$3['Etc/GMT'];
  zones$3['Etc/GMT-0'] = zones$3['Etc/GMT'];

  var zones$4 = zones$3;

  // determine current day (mon, tues)
  // using 'Key-Value Method' from - https://artofmemory.com/blog/how-to-calculate-the-day-of-the-week/

  // const DAYS = [
  //   'Sunday',
  //   'Monday',
  //   'Tuesday',
  //   'Wednesday',
  //   'Thursday',
  //   'Friday',
  //   'Saturday',
  // ];

  const month_code = function (n) {
    let month_codes = [
      null,
      0, //January
      3, //February
      3, //March
      6, //April
      1, //May
      4, //June
      6, //July
      2, //August
      5, //September
      0, //October
      3, //November
      5, //December
    ];
    return month_codes[n]
  };

  const year_code = function (year) {
    let yy = year % 100;
    return (yy + parseInt(yy / 4, 10)) % 7;
  };

  const century_code = function (year) {
    //julian
    if (year < 1752) {
      let c = parseInt(year / 100, 10);
      return (18 - c) % 7;
    }
    //gregorian
    let c = parseInt(year / 100, 10);
    let codes = {
      '17': 4, // 1700s = 4
      '18': 2, // 1800s = 2
      '19': 0, // 1900s = 0
      '20': 6, // 2000s = 6
      '21': 4, // 2100s = 4
      '22': 2, // 2200s = 2
      '23': 0, // 2300s = 0
    };
    return codes[String(c)] || 0
  };

  // https://www.timeanddate.com/date/leapyear.html
  const leap_code = function (year) {
    let is_leap = (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    if (is_leap === true) {
      return -1
    } else {
      return 0
    }
  };

  // which day of the week is it?
  const getDay = function (year, month, date) {
    let yc = year_code(year);
    let mc = month_code(month);
    let cc = century_code(year);
    let dc = date;
    let lc = leap_code(year);
    // (Year Code + Month Code + Century Code + Date Number - Leap Year Code) mod 7
    let day = (yc + mc + cc + dc + lc) % 7;
    return day
    // return DAYS[day]
  };
  var getDay$1 = getDay;


  // 1969-07-20 - sunday
  // 1897-03-14 - sunday
  //1066-10-14 -sat
  // let cal = { year: 2022, month: 10, date: 13 }
  // let cal = { year: 1066, month: 10, date: 14 }
  // let cal = { year: 1897, month: 3, date: 14 }
  // let cal = { year: 1969, month: 7, date: 20 }

  const isValid = function (cal, tz, world) {
    if (!cal) {
      return false
    }
    // required fields
    if (!cal.year && !cal.year === 0) {
      return false
    }
    if (!cal.month || cal.month < 1 || cal.month > 12) {
      return false
    }
    if (!cal.date || cal.date < 1 || cal.date > 31) {
      return false
    }
    // non-required fields
    if (cal.hour && cal.hour < 0 && cal.hour > 24) {
      return false
    }
    if (cal.minute && cal.minute < 0 && cal.minute > 60) {
      return false
    }
    if (cal.second && cal.second < 0 && cal.second > 60) {
      return false
    }
    if (cal.millisecond && cal.millisecond < 0 && cal.millisecond > 1000) {
      return false
    }
    if (cal.offset && cal.offset < -14 && cal.offset > 14) {
      return false
    }
    return true
  };
  var isValid$1 = isValid;

  const isNum = val => typeof val === 'number';

  let mapping$3 = {};
  model.months.forEach((_, i) => {
    if (model.months[i]) {
      mapping$3[model.months[i].shortForm.toLowerCase()] = i;
      mapping$3[model.months[i].longForm.toLowerCase()] = i;
    }
  });
  mapping$3.sept = 9;//extra
  const parseMonth = function (input) {
    if (isNum(input)) {
      return input
    }
    input = input.toLowerCase().trim();
    return mapping$3[input]
  };
  var parseMonth$1 = parseMonth;

  // parse '+05:30' offset according to ISO8601 - 
  //  could be +hh:mm, +hhmm or +hh
  const reg = /^([+-])?([0-9]{1,2}):?([0-9]{2})?$/;

  //pull-apart ISO offsets, like "+0100"
  const parseOffset = (str) => {
    if (!str) {
      return null
    }
    // 'Zulu' is 0
    if (str === 'Z' || str === 'z') {
      return 0
    }
    // tokenize it
    let m = str.match(reg);
    if (m !== null) {
      let [, plus, hour, min] = m;

      hour = parseInt(hour || '', 10) || 0;
      min = parseInt(min || '', 10) || 0;

      // turn minutes into decimal - 30 -> 0.5
      min = min / 60;

      let offset = hour + min;

      // handle negative
      if (plus === '-') {
        offset *= -1;
      }
      return offset
    }
    return null

    //okay, try to match it to a utc timezone
    //remember - this is opposite! a -5 offset maps to Etc/GMT+5  ¯\_(:/)_/¯
    //https://askubuntu.com/questions/519550/why-is-the-8-timezone-called-gmt-8-in-the-filesystem
    // num *= -1
    // return num

    // if (num >= 0) {
    //   num = '+' + num
    // }
    // let tz = 'etc/gmt' + num
    // let zones = s.timezones
    // if (zones[tz]) {
    // log a warning if we're over-writing a given timezone?
    // console.log('changing timezone to: ' + tz)
    // s.tz = tz
    // }
    // return s
  };
  var parseOffset$1 = parseOffset;

  const parseHour = function (str) {
    if (isNum(str)) {
      return str
    }
    str = str.trim().toLowerCase();
    // leading 0s
    str = str.replace(/^[0:]+/, '');
    // '4h'
    str = str.replace(/([0-9])h$/, '$1');
    // '4'
    let n = parseInt(str, 10);
    if (n) {
      return n
    }
    //'5pm'
    let m = str.match(/([0-9]+) ?(am|pm)$/);
    if (m !== null && m[1]) {
      let h = Number(m[1]);
      if (m[2] === 'pm') {
        h += 12;
      }
      return h
    }
    return 0
  };
  var parseHour$1 = parseHour;

  const startOfDay = {
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  };


  // truncate any sub-millisecond values
  const parseMs = function (str = '') {
    str = String(str);
    //js does not support sub-millisecond values 
    // so truncate these - 2021-11-02T19:55:30.087772
    if (str.length > 3) {
      str = str.substring(0, 3);
    } else if (str.length === 1) {
      // assume ms are zero-padded on the left
      // but maybe not on the right.
      // turn '.10' into '.100'
      str = str + '00';
    } else if (str.length === 2) {
      str = str + '0';
    }
    return Number(str) || 0
  };

  const parseTime = (str = '', obj) => {
    obj = Object.assign({}, startOfDay, obj);
    // remove all whitespace
    str = str.replace(/^\s+/, '').toLowerCase();
    //formal time format - 04:30.23
    let arr = str.match(/([0-9]{1,2}):([0-9]{1,2}):?([0-9]{1,2})?[:.]?([0-9]{1,4})?/);
    if (arr !== null) {
      //validate it a little
      let h = Number(arr[1]);
      if (h < 0 || h > 24) {
        return obj
      }
      let m = Number(arr[2]); //don't accept '5:3pm'
      if (arr[2].length < 2 || m < 0 || m > 59) {
        return obj
      }
      obj.hour = h;
      obj.minute = m;
      obj.second = Number(arr[3]) || 0;
      obj.millisecond = parseMs(arr[4]);
      //parse-out am/pm
      let ampm = str.match(/[\\b0-9] ?(am|pm)\b/);
      if (ampm !== null && ampm[1] === 'pm') {
        obj.hour += 12;
      }
      return obj
    }

    // parse hour-only times
    let h = parseHour$1(str);
    if (h !== null) {
      obj.hour = h;
    }
    return obj
  };
  var parseTime$1 = parseTime;

  const parseYear = (str = '') => {
    if (isNum(str)) {
      return str
    }
    str = str.trim();
    // parse '86 shorthand
    if (/^'[0-9][0-9]$/.test(str) === true) {
      let num = Number(str.replace(/'/, ''));
      if (num > 50) {
        return 1900 + num
      }
      return 2000 + num
    }
    let year = parseInt(str, 10);
    // use a given year from options.today
    // if (!year && today) {
    //   year = today.year
    // }
    // fallback to this year
    year = year || new Date().getFullYear();//remove me
    return year
  };

  var parseYear$1 = parseYear;

  const parseDate = (str = '') => {
    if (isNum(str)) {
      return str
    }
    str = str.trim();
    // remove padding
    str = str.replace(/^0+/, '');

    //remove ordinal suffix
    str = str.replace(/([0-9])(st|nd|rd|th)$/i, '$1');

    let date = parseInt(str, 10);

    return date || 1 // coerce zero to one
  };

  var parseDate$1 = parseDate;

  const ampm = function (str) {
    str = str.trim().toLowerCase();
    // a.m.
    str = str.replace(/\./g, '');
    if (str === 'am' || str === 'pm') {
      return str
    }
    return null
  };
  var parseAmpm = ampm;

  let mapping$2 = { tues: 2, thur: 4, thurs: 4 };
  model.days.forEach((_, i) => {
    mapping$2[model.days[i].shortForm.toLowerCase()] = i;
    mapping$2[model.days[i].longForm.toLowerCase()] = i;
  });


  const parseDay = function (str) {
    if (isNum(str)) {
      return str
    }
    str = str.trim().toLowerCase();
    if (mapping$2.hasOwnProperty(str)) {
      return mapping$2[str]
    }
    return null
  };
  var parseDay$1 = parseDay;

  const parseQuarter = function (str) {
    str = str.trim();
    str = str.replace(/^q/, '');
    return parseInt(str, 10) || null
  };
  var parseQuarter$1 = parseQuarter;

  var ymd = [
    // =====
    //  y-m-d
    // =====
    //iso-this 1998-05-30T22:00:00:000Z, iso-that 2017-04-03T08:00:00-0700
    {
      reg: /^(-?0{0,2}[0-9]{3,4})-([0-9]{1,2})-([0-9]{1,2})[T| ]([0-9.:]+)(Z|[0-9\-+:]+)?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[1]),
          month: parseInt(m[2], 10),
          date: parseDate$1(m[3])
        };
        obj.offset = parseOffset$1(m[5]);
        obj = parseTime$1(m[4], obj);
        return obj
      }
    },
    //short-iso "2015-03-25" or "2015/03/25" or "2015/03/25 12:26:14 PM"
    {
      reg: /^([0-9]{4})[-/. ]([0-9]{1,2})[-/. ]([0-9]{1,2})( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[1]),
          month: parseInt(m[2], 10),
          date: parseDate$1(m[3])
        };
        if (obj.month > 12) {
          //support yyyy/dd/mm (weird, but ok)
          obj.date = parseDate$1(m[2]);
          obj.month = parseInt(m[3], 10);
        }
        obj = parseTime$1(m[4], obj);
        return obj
      }
    },

    //text-month "2015-feb-25"
    {
      reg: /^([0-9]{4})[-/. ]([a-z]+)[-/. ]([0-9]{1,2})( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[1]),
          month: parseMonth$1(m[2]),
          date: parseDate$1(m[3] || '')
        };
        obj = parseTime$1(m[4], obj);
        return obj
      }
    }
  ];

  var mdy = [
    // =====
    //  m-d-y
    // =====
    //mm/dd/yyyy - uk/canada "6/28/2019, 12:26:14 PM"
    {
      reg: /^([0-9]{1,2})[-/.]([0-9]{1,2})[-/.]?([0-9]{4})?( [0-9]{1,2}:[0-9]{2}:?[0-9]{0,2} ?(am|pm|gmt))?$/i,
      parse: (m) => {
        let month = parseInt(m[1], 10);
        let date = parseDate$1(m[2]);
        //support dd/mm/yyy
        // if (s.british || month >= 12) {
        //   date = parseInt(m[1], 10)
        //   month = parseInt(m[2], 10) - 1
        // }
        let obj = {
          date,
          month,
          year: parseYear$1(m[3])
        };
        // s = parseTime(s, m[4])
        return obj
      }
    },
    //alt short format - "feb-25-2015"
    {
      reg: /^([a-z]+)[-/. ]([0-9]{1,2})[-/. ]?([0-9]{4}|'[0-9]{2})?( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[3]),
          month: parseMonth$1(m[1]),
          date: parseDate$1(m[2] || '')
        };
        obj = parseTime$1(m[4], obj);
        return obj
      }
    },

    //Long "Mar 25 2015"
    //February 22, 2017 15:30:00
    {
      reg: /^([a-z]+) ([0-9]{1,2})( [0-9]{4})?( ([0-9:]+( ?am| ?pm| ?gmt)?))?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[3]),
          month: parseMonth$1(m[1]),
          date: parseDate$1(m[2] || '')
        };
        obj = parseTime$1(m[4], obj);
        return obj
      }
    },
    // 'Sun Mar 14 15:09:48 +0000 2021'
    {
      reg: /^([a-z]+) ([0-9]{1,2})( [0-9:]+)?( \+[0-9]{4})?( [0-9]{4})?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[5]),
          month: parseMonth$1(m[1]),
          date: parseDate$1(m[2] || '')
        };
        obj = parseTime$1(m[4], obj);
        return obj
      }
    }
  ];

  var dmy = [
    // =====
    //  d-m-y
    // =====
    //common british format - "25-feb-2015"
    {
      reg: /^([0-9]{1,2})[-/]([a-z]+)[-/]?([0-9]{4})?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[3]),
          month: parseMonth$1(m[2]),
          date: parseDate$1(m[1] || '')
        };
        obj = parseTime$1(m[4], obj);
        return obj
      }
    },
    // "25 Mar 2015"
    {
      reg: /^([0-9]{1,2})( [a-z]+)( [0-9]{4}| '[0-9]{2})? ?([0-9]{1,2}:[0-9]{2}:?[0-9]{0,2} ?(am|pm|gmt))?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[3]),
          month: parseMonth$1(m[2]),
          date: parseDate$1(m[1])
        };
        if (!obj.month) {
          return null
        }
        obj = parseTime$1(m[4], obj);
        return obj
      }
    },
    // 01-jan-2020
    {
      reg: /^([0-9]{1,2})[ /]([a-z]+)[ /]([0-9]{4})?( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i,
      parse: (m) => {
        let obj = {
          date: parseDate$1(m[1]),
          month: parseMonth$1(m[2]),
          year: parseYear$1(m[3])
        };
        obj = parseTime$1(m[4], obj);
        return obj
      }
    }
  ];

  var misc$1 = [
    // '2012-06' month-only
    {
      reg: /^([0-9]{4})[-/]([0-9]{2})$/,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[1]),
          month: parseInt(m[2], 10),
        };
        return obj
      }
    },

    //February 2017 (implied date)
    {
      reg: /^([a-z]+) ([0-9]{4})$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[2]),
          month: parseMonth$1(m[1]),
        };
        return obj
      }
    },

    {
      // 'q2 2002'
      reg: /^(q[0-9])( of)?( [0-9]{4})?/i,
      parse: (m) => {
        let q = parseQuarter$1(m[1] || '');
        if (q && q > 0 && q < 5) {
          return {
            year: parseYear$1(m[3]),
            month: (q - 1) * 3
          }
        }
        return {}
      }
    },
    {
      // 'summer 2002'
      reg: /^(spring|summer|winter|fall|autumn)( of)?( [0-9]{4})?/i,
      parse: (m) => {
        m[1] || '';
        // TODO: 
        if (m[3]) {
          let year = parseYear$1(m[3]);
          return { year }
        }
        return {}
      }
    },
    {
      // 'wednesday'
      reg: /^(mon|monday|tues?|tuesday|wed|wednesday|thur?|thursday|fri|friday|sat|saturday|sun|sunday)$/i,
      parse: (m) => {
        if (m[0]) {
          let day = parseDay$1(m[0]);
          return { day }
        }
        return {}
      }
    },
    {
      // '3:00pm'
      reg: /^[0-9:]+(a\.?m\.?|p\.?m\.?)?$/i,
      parse: (m) => {
        let str = m[0] || '';
        let obj = parseTime$1(str.trim());
        if (obj.hour || obj.hour === 0) {
          return obj
        }
        return null
      }
    },
    {
      // '200bc'
      reg: /^[0-9,]+ ?b\.?c\.?$/i,
      parse: (m) => {
        let str = m[0] || '';
        //make year-negative
        str = str.replace(/^([0-9,]+) ?b\.?c\.?$/i, '-$1').trim();
        let obj = {
          year: parseInt(str.trim(), 10),
        };
        return obj
      }
    },
    {
      // '200ad'
      reg: /^[0-9,]+ ?(a\.?d\.?|c\.?e\.?)$/i,
      parse: (m) => {
        let str = m[0] || '';
        let obj = {
          year: parseInt(str.trim(), 10),
        };
        return obj
      }
    },
    {
      // '1992'
      reg: /^[0-9]{4}( ?a\.?d\.?)?$/i,
      parse: (m) => {
        let obj = {
          year: parseYear$1(m[0]),
        };
        return obj
      }
    }
  ];

  const formats = [].concat(ymd, mdy, dmy, misc$1);

  const parseText = function (txt, tz) {
    // normalize it a bit first
    txt = txt.toLowerCase();
    let og = txt;
    txt = txt.replace(/([0-9])(th|rd|st|nd)\b/, '$1');
    txt = txt.replace(/\b(mon|tues?|wed|wednes|thur?s?|fri|sat|satur|sun)(day)?\b/i, '');
    if (!txt) {
      txt = og;
    }
    txt = txt.replace(/,/g, '');
    txt = txt.replace(/ +/g, ' ').trim();
    txt = txt.trim();
    for (let i = 0; i < formats.length; i += 1) {
      let m = txt.match(formats[i].reg);
      if (m !== null) {
        // console.log(`reg #${i} - ${formats[i].reg}`)
        let res = formats[i].parse(m);
        if (res) {
          return res
        }
      }
    }
    return null
  };
  var parseText$1 = parseText;

  const units$3 = ['year', 'month', 'date', 'hour', 'minute', 'second', 'millisecond'];

  const jan1 = {
    month: 1,
    date: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  };

  const getNow = function (tz, world) {
    const { methods } = world;
    let epoch = methods.now();
    return methods.getCal(epoch, tz, world)
  };

  const isNumber$2 = val => {
    return typeof val === 'number'// && isFinite(val)
  };

  // 
  const fillIn = function (obj, tz, world) {
    // assume jan 1?
    if (isNumber$2(obj.year)) {
      return Object.assign({}, jan1, obj)
    }
    // if we have any time properties, zero out the rest
    if (isNumber$2(obj.hour) || isNumber$2(obj.minute) || isNumber$2(obj.second)) {
      obj.minute = obj.minute || 0;
      obj.second = obj.second || 0;
      obj.millisecond = obj.millisecond || 0;
    }
    // if there's no year, assume ours
    let now = getNow(tz, world);
    // otherwise, assume now, for missing values
    let cal = Object.assign({}, now, obj);
    return cal
  };

  const fromObject = function (obj, tz, world) {
    if (typeof obj.month === 'string') {
      obj.month = parseMonth$1(obj.month);
    }
    if (typeof obj.date === 'string') {
      obj.date = parseDate$1(obj.date);
    }
    let cal = fillIn(obj, tz, world);
    return cal
  };

  const fromEpoch = function (input, tz, world) {
    // if the given epoch is really small, they've probably given seconds and not milliseconds
    if (world.config.minimumEpoch && input < world.config.minimumEpoch && input > 0) {
      input *= 1000;
    }
    return { epoch: input, tz }
  };


  const fromArray = function (arr, tz, world) {
    let obj = arr.reduce((h, n, i) => {
      h[units$3[i]] = n;
      return h
    }, {});
    return fromObject(obj, tz, world)
  };

  const fromText = function (txt, tz, world) {
    let obj = parseText$1(txt);
    if (!obj) {
      return obj
    }
    return fillIn(obj, tz, world)
  };

  const isNumber$1 = val => typeof val === 'number' && isFinite(val);
  const isObject$1 = val => Object.prototype.toString.call(val) === '[object Object]';
  const isArray = (arr) => Object.prototype.toString.call(arr) === '[object Array]';
  const isString = val => typeof val === 'string';

  const guessTz = function (cal) {
    // replace tz with iso timezone
    if (cal.offset !== null && cal.offset !== undefined) {
      if (cal.offset < 0) {
        return `Etc/GMT+${Math.abs(cal.offset)}`
      } else {
        return `Etc/GMT-${cal.offset}`
      }
    }
    return null
  };

  const parse = function (input, tz, world) {
    // no input means now
    if (input === null || input === undefined) {
      return { epoch: world.methods.now(), tz }
    }
    // pull-apart input into calendar object
    let cal = {};
    if (isNumber$1(input)) {
      return fromEpoch(input, tz, world)
    }
    if (isArray(input)) {
      cal = fromArray(input, tz, world);
    } else if (isObject$1(input)) {
      // interpret a spacetime object as input
      if (input.isSpacetime === true) {
        return input.clone()
      }
      cal = fromObject(input, tz, world);
    } else if (isString(input)) {
      cal = fromText(input, tz, world);
    }
    // throw an error if input creates invalid date
    if (isValid$1(cal) === false) {
      if (world.config.throwUnparsedDate) {
        // console.error(`Error: invalid spacetime input: '${input}'`)
        // console.error(JSON.stringify(cal, null, 2))
        let err = new Error('InvalidDate');
        err.type = 'InvalidDate';
        throw err
      }
      //fallback to now
      cal = fromObject({}, tz, world);
    }

    // try to pull an tz off end of ISO-string
    if (!tz) {
      tz = guessTz(cal) || world.methods.fallbackTz(world);
    }
    let epoch = world.methods.getEpoch(cal, tz, world);
    return { epoch, tz }

  };
  var parse$1 = parse;

  const isNumber = val => {
    return typeof val === 'number' && isFinite(val)
  };

  // this method is replaced in /two
  const parseTz$1 = function (input, world) {
    let { zones, config } = world;

    if (input === null || input === undefined) {
      return null
    }
    // parse something like '+05:00'
    let h = parseOffset$1(input);
    if (h || h === 0) {
      input = h;
    }
    // shim-together a timezone from a numeric offset
    if (isNumber(input) === true) {
      let n = input;
      if (n === 0) {
        return 'Etc/GMT'
      }
      if (n < 0) {
        return `Etc/GMT+${Math.abs(n)}`//reversed
      }
      return `Etc/GMT${n * -1}`
    }
    if (input === 'z' || input === 'Z') {
      return 'Etc/GMT'
    }
    if (zones.hasOwnProperty(input)) {
      return input // looks good
    }
    if (config.throwUnknownTz) {
      let err = new Error(`Spacetime: Unknown timezone: '${input}'`);
      err.type = 'UnknownTimezone';
      throw err
    }

    return null
  };
  var parseTz$2 = parseTz$1;

  const fallbackTz$2 = function (world) {
    // deduce computer timezone via getTimezoneOffset()?
    if (world.config.tryLocalTimezone) {
      const mins = new Date().getTimezoneOffset();// get (current) timezone offset from js Date
      let h = mins / 60;
      let name = `Etc/GMT${h * -1}`;
      if (world.zones.hasOwnProperty(name)) {
        return name
      }
    }
    return world.config.fallbackTz || null
  };
  var fallbackTz$3 = fallbackTz$2;

  const monthLen = function (n, year, world) {
    const { isLeapYear } = world.methods;
    const { months } = world.model;
    if (n === 2 && isLeapYear(year)) {
      return 29
    }
    return months[n].len
  };
  var monthLen$1 = monthLen;

  // what is the offset on January 1st?
  const getOffset = function (tz, world) {
    const { HOUR } = world.model.ms;
    // apply timezone offset to it
    let zoneFile = world.zones;
    if (tz && zoneFile.hasOwnProperty(tz) && zoneFile[tz]) {
      let zone = zoneFile[tz];
      let offset = zone.offset || 0;
      // are we in DST on Jan 1st?
      // all 16 southern hemisphere zones w/ DST
      if (zone.hem === 's' && zone.dst) {
        offset += zone.change || 1;
      }
      return offset * HOUR
    }
    return 0
  };
  var getOffset$1 = getOffset;

  // const MAXOFFSET = -DAY * 2
  const memo = {};

  const utcStart = function (year, world) {
    const { YEAR, DAY } = world.model.ms;
    const isLeapYear = world.methods.isLeapYear;
    // try and compute this only once
    if (memo.hasOwnProperty(year)) {
      return memo[year]
    }
    let epoch = 0;
    // count up from 1970
    if (year > 1970) {
      for (let y = 1970; y < year; y += 1) {
        if (isLeapYear(y)) {
          epoch += YEAR + DAY;
        } else {
          epoch += YEAR;
        }
        memo[y + 1] = epoch;
      }
    } else {
      // count down from 1970
      let y = 1970;
      while (y > year) {
        y -= 1;
        if (isLeapYear(y)) {
          epoch -= YEAR + DAY;
        } else {
          epoch -= YEAR;
        }
        memo[y] = epoch;
      }
    }
    return epoch
  };



  // get UTC epoch for jan 1
  const yearStart = function (year, tz, world) {
    let epoch = utcStart(year, world);
    epoch -= getOffset$1(tz, world);
    return epoch
  };


  var yearStart$1 = yearStart;

  // from a random epoch, get it's Jan 1st alignment
  const getYear = function (target, tz, world) {
    const { YEAR, DAY } = world.model.ms;
    const MAXOFFSET = DAY * 2;
    let epoch = 0;
    const isLeapYear = world.methods.isLeapYear;
    // apply timezone offset to it
    epoch -= getOffset$1(tz, world);
    let year = 1970;
    // count upwards from 1970
    if (target > MAXOFFSET) {
      while (epoch <= target) {
        let size = YEAR;
        if (isLeapYear(year)) {
          size = YEAR + DAY;
        }
        let tmp = epoch + size;
        if (tmp > target) {
          break
        }
        epoch = tmp;
        year += 1;
      }
    } else {
      // count downwards from 1970
      while (epoch > target) {
        let size = YEAR;
        if (isLeapYear(year)) {
          size = YEAR + DAY;
        }
        epoch -= size;
        year -= 1;
      }
    }
    return { start: epoch, year }
  };
  var getYear$1 = getYear;

  // import isLeapYear from '../_lib/isLeap.js'
  // import { SECOND, MINUTE, HOUR } from '../_lib/millis.js'
  // import MONTHS from '../_lib/months.js'


  const getDate = function (diffDays, year, world) {
    let res = { month: 1, date: 1 };
    if (!diffDays) {
      return res
    }
    const { months } = world.model;
    const { isLeapYear } = world.methods;
    const monthLengths = months.map(o => {
      if (!o) {
        return 0
      }
      return o.len
    });
    let total = 0;
    for (let i = 1; i < months.length; i += 1) {
      let inMonth = monthLengths[i];
      if (i === 2 && isLeapYear(year)) {
        inMonth += 1;
      }
      if (total + inMonth > diffDays) {
        break
      }
      total += inMonth;
      res.month += 1;
    }
    // add remainder to days
    res.date += diffDays - total;
    return res
  };

  const getTime = function (ms, world) {
    const { SECOND, MINUTE, HOUR } = world.model.ms;
    let res = { hour: 0, minute: 0, second: 0, millisecond: 0 };
    // get hour
    res.hour = Math.floor(ms / HOUR);
    ms -= res.hour * HOUR;
    // get minute
    res.minute = Math.floor(ms / MINUTE);
    ms -= res.minute * MINUTE;
    // get second
    res.second = Math.floor(ms / SECOND);
    ms -= res.second * SECOND;
    // remainder milliseconds
    res.millisecond = ms;
    return res
  };

  // take an epoch, return {month, year, date...}
  const computeCal = function (epoch, tz, world) {
    const { zones, model, methods } = world;
    const { getYear, dstChanges } = methods;
    const { DAY, HOUR } = model.ms;
    // get Jan 1 of the year
    let { start, year } = getYear(epoch, tz, world);
    let zone = zones[tz] || {};
    let cal = {
      year,
      month: 1,
      date: 1,
      hour: 0,
      second: 0,
      millisecond: 0,
      offset: zone.offset || 0
    };
    // kick the epoch around, according to our DST offset
    let changes = dstChanges(tz, year, world);
    if (zone.hem === 's') {
      // southern hemisphere
      for (let i = 0; i < changes.length; i += 1) {
        if (epoch < changes[i].epoch) {
          cal.offset = changes[i].offset;
          epoch -= changes[i].delta * HOUR;
          break
        }
      }
      cal.offset += 1;
    } else {
      // northern hemisphere
      for (let i = changes.length - 1; i >= 0; i -= 1) {
        if (epoch >= changes[i].epoch) {
          cal.offset = changes[i].offset;
          epoch += changes[i].delta * HOUR;
          break
        }
      }
    }
    // walk the days
    let diff = epoch - start;
    let daysDiff = Math.floor(diff / DAY);
    // compute month, date
    let resDate = getDate(daysDiff, year, world);
    Object.assign(cal, resDate);
    // compute hour, min, sec..
    let deltaMs = diff - (daysDiff * DAY);
    // console.log(deltaMs / HOUR)
    let resMins = getTime(deltaMs, world);
    Object.assign(cal, resMins);
    return cal
  };
  var getCal$3 = computeCal;

  // import months from '../compute/_lib/months.js'
  // import isLeapYear from '../compute/_lib/isLeap.js'

  const isFloat = function (n) {
    return n !== undefined && Number(n) === n && n % 1 !== 0;
  };

  // ensure we haven't been given any silly numbers
  const validate = function (cal, world) {
    const isLeapYear = world.methods.isLeapYear;
    const months = world.model.months;
    Object.keys(cal).forEach(k => {
      // no decimals allowed
      if (isFloat(cal[k])) {
        cal[k] = parseInt(cal[k], 10);
      }
      // no negatives
      if (cal[k] < 0 && k !== 'year') {
        cal[k] = 0;
      }
    });

    // set defaults
    cal.month = cal.month || 1; //co-erce any zeros to 1s
    cal.date = cal.date || 1; // (same)
    cal.hour = cal.hour || 0;
    cal.minute = cal.minute || 0;
    cal.second = cal.second || 0;
    cal.millisecond = cal.millisecond || 0;

    // range maximums
    if (cal.month && cal.month > 12) {
      cal.month = 12;
    }
    if (cal.date && months[cal.month - 1] && cal.date > months[cal.month - 1].len) {
      // check leap
      if (cal.month === 2 && isLeapYear(cal.year)) {
        cal.date = 29;
      } else {
        cal.date = months[cal.month - 1].len;
      }
    }
    if (cal.hour && cal.hour > 24) {
      cal.month = 24;
    }
    if (cal.minute && cal.minute > 59) {
      cal.month = 59;
    }
    if (cal.second && cal.second > 59) {
      cal.second = 59;
    }
    if (cal.millisecond && cal.millisecond > 999) {
      cal.millisecond = 999;
    }
    return cal
  };
  var validate$1 = validate;

  // import { DAY, HOUR, MINUTE, SECOND } from '../_lib/millis.js'
  // import months from '../_lib/months.js'
  // import isLeap from '../_lib/isLeap.js'

  // compare two cal objects
  const ensureEqual = function (a, b) {
    const units = ['year', 'month', 'date', 'hour', 'minute', 'second', 'millisecond'];
    for (let i = 0; i < units.length; i += 1) {
      let unit = units[i];
      if (a[unit] !== b[unit]) {
        console.error('\n----\nMis-matched unit in walk:', unit); // eslint-disable-line
        // console.error(a, '\n', b) // eslint-disable-line
        return false
      }
    }
    //it's the same
    return true
  };

  const diffDays = function (from, to, world) {
    const { isLeapYear } = world.methods;
    const { months } = world.model;
    let diff = 0;
    // increment months
    for (let n = from.month; n < to.month; n += 1) {
      diff += months[n].len;
      if (n === 2 && isLeapYear(from.year)) {
        diff += 1; //add another
      }
    }
    // delta days (can be negative)
    let days = to.date - from.date;
    diff += days;
    return diff
  };

  // step forward and count milliseconds 
  // until the two calendar objects meet
  const walk$1 = function (epoch, from, to, world) {
    const { DAY, HOUR, MINUTE, SECOND } = world.model.ms;
    // console.log(`from: ${from.year}-${from.month}-${from.date}`)
    // console.log(`  to: ${to.year}-${to.month}-${to.date}`)

    // increment months/days  (we are guaranteed to be in the same year)
    let diff = diffDays(from, to, world);
    epoch += diff * DAY;
    from.month = to.month;
    from.date = to.date;

    // add-up remaining hours
    diff = to.hour - from.hour;
    epoch += diff * HOUR;
    from.hour += diff;

    // remaining minutes
    diff = to.minute - from.minute;
    epoch += diff * MINUTE;
    from.minute += diff;

    // add-up remaining seconds
    diff = to.second - from.second;
    epoch += diff * SECOND;
    from.second += diff;

    // add-up remaining milliseconds
    diff = to.millisecond - from.millisecond;
    epoch += diff;
    from.millisecond += diff;

    // make sure we are complete
    ensureEqual(from, to);

    return epoch
  };
  var walk$2 = walk$1;

  const NEW_YEAR = {
    month: 1,
    date: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  };

  // compare two cal objects
  const isAfter = function (a, b) {
    const units = ['year', 'month', 'date', 'hour', 'minute', 'second', 'millisecond'];
    for (let i = 0; i < units.length; i += 1) {
      let unit = units[i];
      if (a[unit] > b[unit]) {
        return true
      }
      if (a[unit] < b[unit]) {
        return false
      }
    }
    //it's the same
    return true
  };

  const getEpoch = function (cal, tz, world) {
    const { yearStart, dstChanges } = world.methods;
    // set secure defaults
    cal = validate$1(cal, world);

    // set our cal to Jan 1 of this year
    let epoch = yearStart(cal.year, tz, world);
    let have = Object.assign({}, NEW_YEAR, { year: cal.year });

    // consult any DST changes this year
    let changes = dstChanges(tz, cal.year, world).reverse();
    let change = changes.find(c => isAfter(cal, c.cal));
    if (change) {
      epoch = change.epoch;
      have = Object.assign({}, NEW_YEAR, change.cal, { year: cal.year });
    }
    // step-forward, by milliseconds
    epoch = walk$2(epoch, have, cal, world);

    return epoch
  };
  var getEpoch$1 = getEpoch;

  const dstChanges = () => [];

  var methods$5 = {
    // from https://www.timeanddate.com/date/leapyear.html
    isLeapYear: (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0),

    getDay: (cal) => getDay$1(cal.year, cal.month, cal.date),

    // parse input string into epoch
    parse: parse$1,

    // determine timezone
    parseTz: parseTz$2,
    fallbackTz: fallbackTz$3,

    yearStart: yearStart$1,
    getEpoch: getEpoch$1,
    dstChanges,
    getYear: getYear$1,
    getCal: getCal$3,
    monthLen: monthLen$1
  };

  const getCal$2 = (s) => {
    return s.world.methods.getCal(s.epoch, s.tz, s.world)
  };

  let getter$1 = {
    year: (s) => getCal$2(s).year,
    month: (s) => getCal$2(s).month,
    date: (s) => getCal$2(s).date,
    hour: (s) => getCal$2(s).hour,
    minute: (s) => getCal$2(s).minute,
    second: (s) => getCal$2(s).second,
    millisecond: (s) => getCal$2(s).millisecond,
    ampm: (s) => getCal$2(s).hour < 12 ? 'am' : 'pm',
    decade: (s) => Math.floor(getCal$2(s).year / 10) * 10,//  eg '1970'
    century: (s) => Math.floor(getCal$2(s).year / 100) * 100,//  eg '1900'
    millenium: (s) => {
      let num = Math.floor(getCal$2(s).year / 1000);
      return num >= 0 ? num + 1 : num// millenia are 1-based, in AD
    },
    era: (s) => getCal$2(s).year < 0 ? 'BC' : 'AD',
    quarter: (s) => {
      let m = getCal$2(s).month;
      if (m < 3) {
        return 1
      } else if (m < 6) {
        return 2
      } else if (m < 9) {
        return 3
      }
      return 4
    },
    hour12: (s) => {
      let h = getCal$2(s).hour;
      if (h > 12) {
        return h - 12
      }
      if (h === 0) {
        return 12
      }
      return h
    },
    hourFloat: (s) => {
      let { minute, hour } = getCal$2(s);
      return hour + (minute / 60)
    },
    offset: (s) => s.world.methods.getCal(s.epoch, s.tz, s.world).offset,
    monthName: s => s.world.model.months[s.month()].longForm,
    time: s => s.format('time')
  };

  // console.log(Object.keys(getter))
  var getter$2 = getter$1;

  const getCal$1 = (s) => {
    return s.world.methods.getCal(s.epoch, s.tz, s.world)
  };
  const fromCal = function (s, cal) {
    let epoch = s.world.methods.getEpoch(cal, s.tz, s.world);
    return s._from(epoch, s.tz)
  };

  let fns = {
    year: (s, input, fwd) => {
      let cal = getCal$1(s);
      cal.year = parseYear$1(input);
      return fromCal(s, cal)
    },
    month: (s, input, fwd) => {
      let cal = getCal$1(s);
      cal.month = parseMonth$1(input);
      return fromCal(s, cal)
    },
    date: (s, input, fwd) => {
      let cal = getCal$1(s);
      cal.date = parseDate$1(input);
      return fromCal(s, cal)
    },
    hour: (s, input, fwd) => {
      let cal = getCal$1(s);
      cal.hour = parseHour$1(input);
      return fromCal(s, cal)
    },
    minute: (s, input, fwd) => {
      let cal = getCal$1(s);
      cal.minute = Number(input);
      return fromCal(s, cal)
    },
    second: (s, input, fwd) => {
      let cal = getCal$1(s);
      cal.second = Number(input);
      return fromCal(s, cal)
    },
    millisecond: (s, input, fwd) => {
      let cal = getCal$1(s);
      cal.millisecond = Number(input);
      return fromCal(s, cal)
    },
    ampm: (s, input, fwd) => {
      let cal = getCal$1(s);
      let h = cal.hour;
      let val = parseAmpm(input);
      if (val === 'am') {
        h = h > 12 ? h - 12 : h;
      } else if (val === 'pm') {
        h = h < 12 ? h + 12 : h;
      }
      cal.hour = h;
      return fromCal(s, cal)
    },

    // eg '1970'
    decade: function (s, input, fwd) {
      let cal = getCal$1(s);
      let r = cal.year % 10;
      cal.year = Number(input) + r;
      return fromCal(s, cal)
    },
    // eg '1900'
    century: function (s, input, fwd) {
      let cal = getCal$1(s);
      let r = cal.year % 100;
      cal.year = Number(input) + r;
      return fromCal(s, cal)
    },
    // eg 1
    millenium: function (s, input, fwd) {
      let cal = getCal$1(s);
      let r = cal.year % 1000;
      let m = Number(input) - 1;
      cal.year = (m * 1000) + r;
      return fromCal(s, cal)
    },

    era: (s, input, fwd) => {
      let cal = getCal$1(s);
      input = input.toLowerCase().replace(/\./g, '').trim();
      if (input === 'bc' && cal.year > 0) {
        cal.year *= -1;
      }
      return fromCal(s, cal)
    },
    quarter: (s, input, fwd) => {
      let cal = getCal$1(s);
      cal = Object.assign(cal, { date: 1, hour: 0, minute: 0, second: 0, millisecond: 0 });
      if (input === 1) {
        cal.month = 1;//jan 1
      } else if (input === 2) {
        cal.month = 3;//apr 1
      } else if (input === 3) {
        cal.month = 6;//july 1
      } else if (input === 4) {
        cal.month = 9;//oct 1
      }
      cal.date = 1;
      return fromCal(s, cal)
    },

    hourFloat: (s, input, fwd) => {
      input = Number(input);
      let cal = getCal$1(s);
      cal.hour = Math.floor(input);
      cal.minute = Math.floor((input % 1) * 60);// (0.25 -> 15)
      return fromCal(s, cal)
    },
    hour12: (s, input, fwd) => {
      //TODO: 
    },
    offset: (s, input) => {
      parseOffset$1(input);
      //TODO: 
    },
    time: (s, input, fwd) => {
      let cal = Object.assign(getCal$1(s), parseTime$1(input));
      return fromCal(s, cal)
    },

  };
  fns.monthName = fns.month;
  // console.log(Object.keys(fns))
  var setter$1 = fns;

  const mapping$1 = {
    milliseconds: 'millisecond',
    ms: 'millisecond',
    seconds: 'second',
    s: 'second',
    minutes: 'minute',
    min: 'minute',
    mins: 'minute',
    hours: 'hour',
    h: 'hour',
    hr: 'hour',
    dates: 'date',
    day: 'date',
    days: 'date',
    months: 'month',
    years: 'year',
    quarters: 'quarter',
    centuries: 'century',
    millenia: 'millenium',
  };

  const order = [
    'millenium',
    'century',
    'decade',
    'year',
    'quarter',
    'month',
    'week',
    'date',
    'hour',
    'minute',
    'second',
    'millisecond',
  ];
  const isKnown = new Set(order);

  const getUnit = function (input = '') {
    if (typeof input !== 'string') {
      input = String(input);
    }
    input = input.toLowerCase().trim();
    if (mapping$1.hasOwnProperty(input)) {
      input = mapping$1[input];
    }
    if (isKnown.has(input)) {
      return input
    }
    console.error(`Unknown unit: '${input}'`);
    return null
  };

  // import monthLen from '../../compute/_lib/monthLen.js'

  let assumed = {
    month: 1, //co-erce any zeros to 1s
    date: 1, // (same)
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  };

  const rollDays = function (cal, world) {
    const { monthLen } = world.methods;
    let len = monthLen(cal.month, cal.year, world);
    while (cal.date > len) {
      cal.date -= len;
      cal.month += 1;
      if (cal.month > 12) {
        cal.year += Math.floor(cal.month / 12);
        cal.month = cal.month % 12;
      }
      len = monthLen(cal.month, cal.year, world);
    }
    return cal
  };

  const rollFwd = function (cal, world) {
    const { monthLen } = world.methods;
    if (cal.millisecond > 999) {
      cal.second += Math.floor(cal.millisecond / 1000);
      cal.millisecond = cal.millisecond % 1000;
    }
    // second
    if (cal.second > 59) {
      cal.minute += Math.floor(cal.second / 60);
      cal.second = cal.second % 60;
    }
    // minute
    if (cal.minute > 59) {
      cal.hour += Math.floor(cal.minute / 60);
      cal.minute = cal.minute % 60;
    }
    // hour (1-based)
    if (cal.hour > 23) {
      cal.date += Math.floor(cal.hour / 24);
      cal.hour = cal.hour % 24;
    }
    // resolve the month, first
    if (cal.month > 12) {
      cal.year += Math.floor(cal.month / 12);
      cal.month = cal.month % 12;
    }
    // now we can do the date+month
    let len = monthLen(cal.month, cal.year, world);
    if (cal.date > len) {
      cal = rollDays(cal, world);
    }
    return cal
  };

  const rollBkwd = function (cal, world) {
    const { monthLen } = world.methods;
    // fix negatives
    while (cal.millisecond < 0) {
      cal.second -= 1;
      cal.millisecond += 1000;
    }
    while (cal.second < 0) {
      cal.minute -= 1;
      cal.second += 60;
    }
    while (cal.minute < 0) {
      cal.hour -= 1;
      cal.minute += 60;
    }
    while (cal.hour < 0) {
      cal.date -= 1;
      cal.hour += 24;
    }
    while (cal.date < 1) {
      cal.month -= 1;
      if (cal.month < 1) {
        cal.year -= 1;
        cal.month += 12;
      }
      let len = monthLen(cal.month, cal.year, world);
      cal.date += len;
    }
    while (cal.month < 1) {
      cal.year -= 1;
      cal.month += 12;
    }
    return cal
  };

  // do a calendar-walk
  const walk = function (cal, n, unit, world) {
    // console.log('====', n, unit, '===')
    cal = Object.assign({}, assumed, cal);
    unit = getUnit(unit);
    cal[unit] += n;
    // roll backward
    cal = rollBkwd(cal, world);
    // roll forward
    cal = rollFwd(cal, world);
    return cal
  };
  var tickBy = walk;

  // console.log(walk({ year: 2019, month: 4, date: 4 }))

  var dayMethods = {

    // this one is tricky!
    day: function (input, fwd) {
      const { epoch, tz, world } = this;
      const { getDay, getCal } = world.methods;
      let cal = world.methods.getCal(epoch, tz, world);
      if (input !== undefined) {
        let day = getDay(cal.year, cal.month, cal.date);
        if (day === input) {
          return cal
        }
        let diff = input - day;
        // go in a specific direction
        if (diff < 0 && fwd === true) {
          diff = 7 + diff;
        } else if (diff > 0 && fwd === false) {
          diff = diff - 7;
        }
        return tickBy(cal, diff, 'date', world)
      }
      return world.methods.getDay(cal)
    },
    // wednesday/friday
    dayName: function (input) {
      const { world } = this;
      let n = this.day();
      return world.model.days[n].longForm
    },
  };

  function titleCase(str) {
    if (!str) {
      return ''
    }
    return str[0].toUpperCase() + str.substr(1)
  }

  function ordinal(i) {
    let j = i % 10;
    let k = i % 100;
    if (j === 1 && k !== 11) {
      return i + 'st'
    }
    if (j === 2 && k !== 12) {
      return i + 'nd'
    }
    if (j === 3 && k !== 13) {
      return i + 'rd'
    }
    return i + 'th'
  }

  function zeroPad(str, len = 2) {
    let pad = '0';
    str = str + '';
    return str.length >= len ? str : new Array(len - str.length + 1).join(pad) + str
  }

  const getter = {
    week: (s) => {
      let start = s.startOf('year').startOf('week');
      return start.diff(s, 'week')
    },
    dayOfYear: (s) => {
      let start = s.startOf('year');
      return start.diff(s, 'day')
    }
  };

  const setter = {
    week: (s, input) => {
      let d = s.startOf('year').startOf('week');
      return d.add(input, 'week')
    },
    dayOfYear: (s, input) => {
      let d = s.startOf('year');
      return d.add(input, 'day')
    }
  };

  var misc = {


    monthName: function (input) {
      const { world } = this;
      let n = this.month();
      return world.model.months[n].longForm
    },
    week: function (input) {
      if (input !== undefined) {
        return setter.week(this, input)
      }
      return getter.week(this)
    },

    dayOfYear: function (input) {
      if (input !== undefined) {
        let s = this.startOf('year');
        return s.add(input, 'day')
      }
      return getter.dayOfYear(this)
    },
    daysInMonth: function () {
      const monthLen = this.world.methods.monthLen;
      return monthLen(this.month(), this.year(), this.world)
    },
    isLeapYear: function () {
      const isLeapYear = this.world.methods.isLeapYear;
      return isLeapYear(this.year())
    },
    timezone: function () {
      return {
        name: this.tz,
        // hasDst: true,
        // default_offset: -4,
        // hemisphere: 'North',
        // current: { offset: -5, isDST: false },
        // change: { start: '03/12:02', back: '11/05:02' }
      }
    },

    // time: function (input) {
    //   if (input !== undefined) {
    //     let { epoch, tz, world } = this
    //     let cal = world.methods.getCal(epoch, tz, world)
    //     let c = setters.time(input, cal, tz)
    //     let e = world.methods.getEpoch(c, tz, this.world)
    //     return this._from(e, tz)
    //   }
    //   return `${this.hour12()}:${String(this.minute()).padStart(2, '0')}${this.ampm()}`
    // },

    clone: function () {
      return this._from(this.epoch, this.tz)
    },

    isValid: () => true,

    hasDst: function () {
      let { tz, world } = this;
      return world.zones[tz].dst
    },
    isAsleep: function () {
      return false
    },

    inDst: function () {
      let { epoch, tz, world } = this;
      const { getCal, dstChanges } = world.methods;
      // if it doesn't have dst
      if (!this.hasDst()) {
        return false
      }
      let cal = getCal(epoch, tz, world);
      dstChanges(tz, cal.year, world);
      // console.log(res)
      return true
    },

    weekStart: function () {
      return this.world.config.weekStart
    },
    json: function () {
      let { epoch, tz, world } = this;
      const { getCal, dstChanges } = world.methods;
      let out = getCal(epoch, tz, world);
      out.epoch = epoch;
      out.tz = tz;
      let z = world.zones[tz] || {};
      out.hem = z.hem;
      // out.abbrevs = z.shrt
      out.dst = dstChanges(tz, out.year);
      return out
    }
  };

  // getter/setter functions are overloaded
  let methods$4 = Object.keys(getter$2).reduce((h, unit) => {
    h[unit] = function (input, fwd) {
      if (typeof input === 'undefined') {
        return getter$2[unit](this)
      }
      return setter$1[unit](this, input, fwd)
    };
    return h
  }, {});

  Object.assign(methods$4, dayMethods, misc);
  var units$2 = methods$4;

  // import g from '../getter/index.js'

  const fmt$1 = {

    day: (s) => titleCase(s.dayName()),
    'day-short': (s) => titleCase(s.world.model.days[s.day()].shortForm),
    'day-number': (s) => s.day(),
    'day-ordinal': (s) => ordinal(s.day()),
    date: (_, cal) => cal.date,
    'date-ordinal': (_, cal) => ordinal(cal.date),
    month: (s) => s.monthName(),
    'month-short': (s, cal) => s.world.model.months[cal.month].shortForm,
    'month-number': (_, cal) => cal.month,
    'month-ordinal': (_, cal) => ordinal(cal.month),
    'iso-month': (_, cal) => zeroPad(cal.month),
    year: (_, cal) => cal.year > 0 ? cal.year : `${Math.abs(cal.year)} BC`,
    'year-short': (_, cal) => cal.year > 0 ? `'${String(cal.year).substring(2, 4)}` : Math.abs(cal.year) + ' BC',
    'iso-year': (_, cal) => {
      let str = zeroPad(Math.abs(cal.year), 4); //0-padded
      if (cal.year < 0) {
        return '-' + zeroPad(str, 6)  //negative years are for some reason 6-digits ('-00008')
      }
      return str
    },
    'time-24': (s) => `${zeroPad(s.hour24())}:${zeroPad(s.minute())}`,

    hour: (s) => s.hour12(),
    'hour-24': (_, cal) => cal.hour,
    minute: (_, cal) => cal.minute,
    second: (_, cal) => cal.second,
    ms: (_, cal) => cal.millisecond,
    millisecond: (_, cal) => cal.millisecond,
    'millisecond-pad': (_, cal) => zeroPad(cal.millisecond, 3),

    ampm: (s) => s.ampm(),
    AMPM: (s) => s.ampm().toUpperCase(),
    quarter: (s) => 'Q' + s.quarter(),

    // turn timezone 5.25 into '+05:15'
    offset: (s, cal) => {
      let n = cal.offset || s.offset() || 0;
      if (n === 0) {
        return 'Z'
      }
      let out = n <= 0 ? '-' : '+';
      n = Math.abs(n);
      // add hour
      let h = parseInt(n, 10);
      out += String(h).padStart(2, '0');
      // add minute
      let decimal = n % 1;
      if (decimal) {
        let min = decimal * 60;
        out += ':' + String(min).padStart(2, '0');
      } else {
        out += ':00';
      }
      return out
    },
    time: (s, cal) => `${s.hour12()}:${String(cal.minute).padStart(2, '0')}${s.ampm()}`,
  };
  // compound ones
  fmt$1['iso-short'] = (s, cal) => `${fmt$1['iso-year'](s, cal)}-${zeroPad(cal.month)}-${zeroPad(cal.date)}`;
  fmt$1['iso-medium'] = (s, cal) => `${fmt$1['iso-short'](s, cal)}T${zeroPad(cal.hour)}:${zeroPad(cal.minute)}:${zeroPad(cal.second)}.${zeroPad(cal.millisecond, 3)}`;
  fmt$1['iso'] = (s, cal) => `${fmt$1['iso-medium'](s, cal)}${fmt$1.offset(s, cal)}`;
  //i made these up
  fmt$1['nice'] = (s, cal) => `${fmt$1['month-short'](s, cal)} ${fmt$1['date-ordinal'](s, cal)}, ${s.time()}`;
  fmt$1['nice-day'] = (s, cal) => `${fmt$1['day-short'](s, cal)} ${fmt$1['month-short'](s, cal)} ${fmt$1['date-ordinal'](s, cal)}`;
  fmt$1['nice-year'] = (s, cal) => `${fmt$1['month-short'](s, cal)} ${fmt$1['date-ordinal'](s, cal)}, ${cal.year}`;
  fmt$1['iso-utc'] = (s, cal) => s._from(s.epoch, 'Etc/GMT').format('iso');

  // aliases
  const aliases$2 = {
    'hour-12': 'hour',
    'day-name': 'day',
    'month-name': 'month',
    'iso 8601': 'iso',
    'time-h24': 'time-24',
    'time-12': 'time',
    'time-h12': 'time',
    tz: 'timezone',
    'day-num': 'day-number',
    'month-num': 'month-number',
    'month-iso': 'iso-month',
    'year-iso': 'iso-year',
    'nice-short': 'nice',
    'nice-short-24': 'nice-24',
    mdy: 'numeric-us',
    dmy: 'numeric-uk',
    ymd: 'numeric',
    'yyyy/mm/dd': 'numeric',
    'mm/dd/yyyy': 'numeric-us',
    'dd/mm/yyyy': 'numeric-us',
    'little-endian': 'numeric-uk',
    'big-endian': 'numeric',
    'day-nice': 'nice-day',
  };
  let pads = ['day', 'date', 'month', 'hour', 'minute', 'second', 'hour-24', 'hour-12'];
  pads.forEach(k => {
    fmt$1[k + '-pad'] = (s, cal) => zeroPad(fmt$1[k](s, cal));
  });
  Object.keys(aliases$2).forEach((k) => {
    fmt$1[k] = fmt$1[aliases$2[k]];
  });

  var fmts = fmt$1;

  // import { formatTimezone } from '../../fns.js'
  //parse this insane unix-time-templating thing, from the 19th century
  //http://unicode.org/reports/tr35/tr35-25.html#Date_Format_Patterns

  //time-symbols we support
  const mapping = {
    G: (s) => s.era(),
    GG: (s) => s.era(),
    GGG: (s) => s.era(),
    GGGG: (s) => (s.era() === 'AD' ? 'Anno Domini' : 'Before Christ'),
    //year
    y: (_, cal) => cal.year,
    yy: (s) => zeroPad(Number(String(s.year()).substring(2, 4))), //last two chars
    yyy: (_, cal) => cal.year,
    yyyy: (_, cal) => cal.year,
    yyyyy: (_, cal) => '0' + cal.year,
    // u: (s) => {},//extended non-gregorian years

    //quarter
    Q: (s) => s.quarter(),
    QQ: (s) => s.quarter(),
    QQQ: (s) => s.quarter(),
    QQQQ: (s) => s.quarter(),

    //month
    M: (_, cal) => cal.month,
    MM: (_, cal) => zeroPad(cal.month),
    MMM: (s) => s.monthName(),
    MMMM: (s) => titleCase(s.monthName()),

    //week
    w: (s) => s.week(),
    ww: (s) => zeroPad(s.week()),
    //week of month
    // W: (s) => s.week(),

    //date of month
    d: (_, cal) => cal.date,
    dd: (_, cal) => zeroPad(cal.date),
    //date of year
    D: (s) => s.dayOfYear(),
    DD: (s) => zeroPad(s.dayOfYear()),
    DDD: (s) => zeroPad(s.dayOfYear(), 3),

    // F: (s) => {},//date of week in month
    // g: (s) => {},//modified julian day

    //day
    E: (s) => fmts['day-short'](s),
    EE: (s) => fmts['day-short'](s),
    EEE: (s) => fmts['day-short'](s),
    EEEE: (s) => fmts['day'](s),
    EEEEE: (s) => fmts['day'](s)[0],
    e: (s) => fmts['day'](s),
    ee: (s) => fmts['day'](s),
    eee: (s) => fmts['day-short'](s),
    eeee: (s) => fmts['day'](s),
    eeeee: (s) => fmts['day'](s)[0],

    //am/pm
    a: (s) => s.ampm().toUpperCase(),
    aa: (s) => s.ampm().toUpperCase(),
    aaa: (s) => s.ampm().toUpperCase(),
    aaaa: (s) => s.ampm().toUpperCase(),

    //hour
    h: (s) => s.hour12(),
    hh: (s) => zeroPad(s.hour12()),
    H: (_, cal) => cal.hour,
    HH: (_, cal) => zeroPad(cal.hour),
    // j: (s) => {},//weird hour format

    m: (_, cal) => cal.minute,
    mm: (_, cal) => zeroPad(cal.minute),
    s: (_, cal) => cal.second,
    ss: (_, cal) => zeroPad(cal.second),

    //milliseconds
    SSS: (s) => zeroPad(s.millisecond(), 3),
    //milliseconds into the day
    A: (s) => s.epoch - s.startOf('day').epoch,
    //timezone
    z: (s) => s.tz,
    zz: (s) => s.tz,
    zzz: (s) => s.tz,
    zzzz: (s) => s.tz,
    Z: (s) => s.format('offset').replace(/:/, ''),
    ZZ: (s) => s.format('offset').replace(/:/, ''),
    ZZZ: (s) => s.format('offset').replace(/:/, ''),
    ZZZZ: (s) => s.format('offset')
  };

  const addAlias = (char, to, n) => {
    let name = char;
    let toName = to;
    for (let i = 0; i < n; i += 1) {
      mapping[name] = mapping[toName];
      name += char;
      toName += to;
    }
  };
  addAlias('q', 'Q', 4);
  addAlias('L', 'M', 4);
  addAlias('Y', 'y', 4);
  addAlias('c', 'e', 4);
  addAlias('k', 'H', 2);
  addAlias('K', 'h', 2);
  addAlias('S', 's', 2);
  addAlias('v', 'z', 4);
  addAlias('V', 'Z', 4);

  // support unix-style escaping with ' character
  const escapeChars = function (arr) {
    for (let i = 0; i < arr.length; i += 1) {
      if (arr[i] === `'`) {
        // greedy-search for next apostrophe
        for (let o = i + 1; o < arr.length; o += 1) {
          if (arr[o]) {
            arr[i] += arr[o];
          }
          if (arr[o] === `'`) {
            arr[o] = null;
            break
          }
          arr[o] = null;
        }
      }
    }
    return arr.filter((ch) => ch)
  };

  //combine consecutive chars, like 'yyyy' as one.
  const combineRepeated = function (arr) {
    for (let i = 0; i < arr.length; i += 1) {
      let c = arr[i];
      // greedy-forward
      for (let o = i + 1; o < arr.length; o += 1) {
        if (arr[o] === c) {
          arr[i] += arr[o];
          arr[o] = null;
        } else {
          break
        }
      }
    }
    // '' means one apostrophe
    arr = arr.filter((ch) => ch);
    arr = arr.map((str) => {
      if (str === `''`) {
        str = `'`;
      }
      return str
    });
    return arr
  };

  const unixFmt = (s, str, cal) => {
    let arr = str.split('');
    // support character escaping
    arr = escapeChars(arr);
    //combine 'yyyy' as strins.
    arr = combineRepeated(arr);
    return arr.reduce((txt, c) => {
      if (mapping[c] !== undefined) {
        txt += String(mapping[c](s, cal) || '');
      } else {
        // 'unescape'
        if (/^'.+'$/.test(s)) {
          c = c.replace(/'/g, '');
        }
        txt += c;
      }
      return txt
    }, '')
  };
  var unixFmt$1 = unixFmt;

  const multiReplace = function (s, str, cal) {
    let sections = /\{(.+?)\}/g;
    str = str.replace(sections, (_, name) => {
      name = name.toLowerCase().trim();
      if (fmts.hasOwnProperty(name)) {
        return fmts[name](s, cal)
      }
      return `{${name}}`
    });
    return str
  };

  const getCal = (s) => s.world.methods.getCal(s.epoch, s.tz, s.world);

  let methods$3 = {
    format: function (fmt = 'iso-short') {
      let cal = getCal(this);
      if (fmt && fmts.hasOwnProperty(fmt)) {
        return fmts[fmt](this, cal)
      }
      return multiReplace(this, fmt, cal)
    },
    unixFmt: function (fmt) {
      let cal = getCal(this);
      return unixFmt$1(this, fmt, cal)
    },
    iso: function () {
      return this.format('iso')
    }
  };

  // add extra wrappers for format methods
  // let diriv = ['iso']
  // diriv.forEach(fn => {
  //   methods[fn] = function () {
  //     const getCal = this.methods.getCal
  //     let cal = getCal(this.epoch, this.tz, this.world)
  //     return fmts[fn](cal)
  //   }
  // })

  var fmt = methods$3;

  var add$2 = {

    add: function (n, unit) {
      let { epoch, tz, world } = this;
      const { getCal, getEpoch } = world.methods;
      const units = world.model.ms;
      // let epoch = add(this.epoch, n, unit)
      if (n === 0 || !unit) {
        return this._from(epoch, tz)
      }
      unit = getUnit(unit);
      // millisecond-math for these units
      if (units.hasOwnProperty(unit)) {
        let ms = units[unit];      // how many milliseconds are we adding?
        epoch += ms * n;
        return this._from(epoch, tz)
      }
      // misc units
      if (unit === 'week' || unit === 'weeks') {
        n *= 7;
        unit = 'day';
      }
      if (unit === 'quarter' || unit === 'quarters') {
        n *= 3;
        unit = 'month';
      }
      if (unit === 'decade' || unit === 'decades') {
        n *= 10;
        unit = 'year';
      }
      if (unit === 'century' || unit === 'centuries') {
        n *= 100;
        unit = 'year';
      }
      // add a 'tick' unit
      let cal = getCal(epoch, tz, world);
      cal = tickBy(cal, n, unit, world);
      let e = getEpoch(cal, tz, world);
      return this._from(e, tz)
    },

    subtract: function (n, unit) {
      return this.add(n * -1, unit)
    },
  };

  const add$1 = (a, b) => Object.assign({}, a, b);

  // which zeros to cascade, for 'start of hour', etc.
  let z = { millisecond: {} };
  z.second = add$1(z.millisecond, { millisecond: 0 });
  z.minute = add$1(z.second, { second: 0 });
  z.hour = add$1(z.minute, { minute: 0 });
  z.date = add$1(z.hour, { hour: 0 });
  z.month = add$1(z.date, { date: 1 });
  z.year = add$1(z.month, { month: 1 });

  const roundYear = (c, by) => {
    c.year = Math.floor(c.year / by) * by;
    return c
  };

  const startMisc = {
    quarterHour: (c) => {
      let m = c.minute;
      if (m >= 45) {
        c.minute = 45;
      } else if (m >= 30) {
        c.minute = 30;
      } else if (m >= 15) {
        c.minute = 15;
      } else {
        c.minute = 0;
      }
      return Object.assign(c, { millisecond: 0, second: 0 })
    },
    decade: (c) => roundYear(c, 10),
    century: (c) => roundYear(c, 100),
    millenium: (c) => roundYear(c, 1000)
  };

  var startOf = {
    startOf: function (unit) {
      const { tz, epoch, world } = this;
      const { getCal, getEpoch } = world.methods;
      unit = getUnit(unit);
      if (!unit) {
        return this
      }
      let cal = getCal(epoch, tz, world);
      if (z.hasOwnProperty(unit)) {
        cal = Object.assign(cal, z[unit]);
      } else if (startMisc.hasOwnProperty(unit)) {
        cal = startMisc[unit](cal);
      }
      // this one is tricky
      if (unit === 'week') {
        let s = this;//.day(this.world.config.weekStart)
        s = s.startOf('day');
        cal = getCal(s.epoch, s.tz, world);
      }
      let e = getEpoch(cal, this.tz, this.world);
      return this._from(e)
    },
    next: function (unit) {
      unit = getUnit(unit);
      if (!unit) {
        return this
      }
      let s = this.startOf(unit);
      return s.add(1, unit)
    },
    last: function (unit) {
      unit = getUnit(unit);
      if (!unit) {
        return this
      }
      let s = this.startOf(unit);
      return s.minus(1, unit)
    },
    endOf: function (unit) {
      unit = getUnit(unit);
      if (!unit) {
        return this
      }
      let s = this.next(unit);  // go to next one, step back 1ms
      s = s.subtract(1, 'millisecond');
      return s
    },
  };

  var add = Object.assign(add$2, startOf);

  //increment until dates are the same
  const climb = (a, b, unit) => {
    // do fast-mode for these units
    if (unit === 'milliseconds') {
      return b.epoch - a.epoch
    }
    if (unit === 'seconds') {
      return Math.floor((b.epoch - a.epoch) / 1000)
    }
    if (unit === 'minutes') {
      return Math.floor((b.epoch - a.epoch) / (1000 * 60))
    }
    // slow-mode for these units
    let n = 0;
    while (a.isBefore(b)) {
      //do proper, expensive increment to catch all-the-tricks
      a = a.add(1, unit);
      n += 1;
    }
    //oops, we went too-far..
    if (a.isAfter(b, unit)) {
      n -= 1;
    }
    return n
  };

  // do a thurough +=1 on the unit, until they match
  // for speed-reasons, only used on day, month, week.
  const diffOne = (a, b, unit) => {
    if (a.isBefore(b)) {
      return climb(a, b, unit)
    } else {
      return climb(b, a, unit) * -1 //reverse it
    }
  };

  var diffOne$1 = diffOne;

  const units$1 = [
    'milliseconds',
    'seconds',
    'minutes',
    'hours',
    'days',
    'months',
    'years',
    // 'quarters',
    // 'weeks',
  ];

  var diff = {
    // 
    diff: function (b, unit) {
      b = this._from(b);
      if (unit) {
        unit = getUnit(unit);
        return diffOne$1(this, b, unit)
      }
      return units$1.reduce((h, u) => {
        h[u] = diffOne$1(this, b, u);
        return h
      }, {})
    },
    since: function (b, unit) {
      unit = getUnit(unit);
      return {}
    }
  };

  //make a string, for easy comparison between dates
  const print = {
    millisecond: (s) => s.epoch,
    second: (s) => [print.minute(s), s.second()].join('-'),
    minute: (s) => [print.hour(s), s.minute()].join('-'),
    hour: (s) => [print.date(s), s.hour()].join('-'),
    date: (s) => [print.month(s), s.date()].join('-'),
    month: (s) => [print.year(s), s.month()].join('-'),
    year: (s) => s.year(),
    // misc ones
    week: (s) => [s.year(), s.week()].join('-'),
    quarter: (s) => [s.year(), s.quarter()].join('-'),
    season: (s) => [s.year(), s.season()].join('-'),
    decade: (s) => s.decade(),
    century: (s) => s.century(),
  };

  const isObject = function (obj) {
    return obj && Object.prototype.toString.call(obj) === '[object Object]'
  };

  let methods$2 = {
    isSame: function (b, unit) {
      // support backwards params
      if (typeof b === 'string' && isObject(unit) && unit.isSpacetime) {
        let tmp = b;
        b = unit;
        unit = tmp;
      }
      unit = getUnit(unit);
      if (!unit) {
        return null
      }
      b = this._from(b);
      return print[unit](this) === print[unit](b)
    },
    isBefore: function (b) {
      b = this._from(b);
      return this.epoch < b.epoch
    },
    isAfter: function (b) {
      b = this._from(b);
      return this.epoch > b.epoch
    },
    isEqual: function (b) {
      b = this._from(b);
      return this.epoch === b.epoch
    },
    isBetween: function (start, end, isInclusive = false) {
      start = this._from(start);
      end = this._from(end);
      let inside = this.epoch > start.epoch && this.epoch < end.epoch;
      if (!inside && isInclusive) {
        return this.epoch === start.epoch || this.epoch === end.epoch
      }
      return inside
    },
    every: function (unit, end) {
      unit = getUnit(unit);
      if (!unit) {
        return []
      }
      let result = [];
      end = this._from(end);
      let d = this.clone();
      while (d.isBefore(end)) {
        result.push(d);
        d = d.add(1, unit);
      }
      return result
    },
    // round up or down on this unit
    nearest: function (unit) {
      unit = getUnit(unit);
      let before = this.startOf(unit);
      let next = this.next(unit);
      let diffDown = this.epoch - before.epoch;
      let diffUp = Math.abs(this.epoch - next.epoch);
      if (diffUp > diffDown) {
        return before// go up
      }
      return next
    },

  };
  Object.assign(methods$2, diff);
  var compare = methods$2;

  /* eslint-disable no-console */
  const cyan = str => '\x1b[36m' + str + '\x1b[0m';
  const yellow = str => '\x1b[33m' + str + '\x1b[0m';
  const dim = str => '\x1b[2m' + str + '\x1b[0m';

  const clientSide = function (s) {
    console.log('%c -=-=- ', 'background-color:#6699cc;');
    console.groupCollapsed(`${s.epoch}   ${s.tz}`);
    let out = {
      year: s.year(),
      month: `${s.monthName()} (${s.month()})`,
      date: `${s.format('date-ordinal')})`,
      time: `${s.time()})`,
      tz: `${s.tz})`
    };
    console.table(out);
    console.groupEnd();
  };

  const serverSide = function (s) {
    console.log('\n');
    console.log(` ${dim(s.epoch)}  ${cyan(s.format('offset'))}\n`);
    console.log(`  │ ${dim('year' + ':').padEnd(14)}  ${cyan(s.year())}`);
    console.log(`  │ ${dim('month' + ':').padEnd(14)}  ${cyan(s.monthName())} (${cyan(s.month())})`);
    console.log(`  │ ${dim('date' + ':').padEnd(14)}  ${cyan(s.format('date-ordinal'))} `);//(${cyan(s.format('day-short'))})
    console.log(`  │ ${dim('time' + ':').padEnd(14)}  ${cyan(s.time())} `);
    console.log(`  │ ${dim('day' + ':').padEnd(14)}  ${cyan(s.dayName())} `);
    console.log(`  │ ${dim('tz' + ':').padEnd(14)}  ${yellow(s.tz)} `);
    console.log(`  │ ${dim('sec' + ':').padEnd(14)}  ${cyan(s.format('{second-pad}:{millisecond-pad}'))}`);
    console.log('\n');
  };


  const debug = function () {
    // is client-side
    if (typeof window !== 'undefined' && window.document) {
      return clientSide(this)
    }
    return serverSide(this)
  };

  var debug$1 = debug;

  // add method aliases
  const aliases = {
    'fmt': 'format',
    'text': 'format',
    'leapYear': 'isLeapYear',
    'isLeap': 'isLeapYear',
    'inDST': 'inDst',
    'hasDST': 'hasDst',
    'hours': 'hour',
    'minutes': 'minute',
    'seconds': 'second',
    'minus': 'subtract',
    'plus': 'add',
    'isDst': 'inDst',
    'log': 'debug',
    // ['set', '_from'],
    //   fns.monthName = fns.month
    // fns.dayName = fns.day
    // fns.hour12 = fns.hour
  };
  var aliases$1 = aliases;

  const percent = (part, total) => {
    let num = (part / total) * 100;
    num = Math.round(num * 10) / 10;
    return num;
  };

  const units = ['year', 'month', 'date', 'hour', 'minute', 'second'];
  const progress = function (unit) {
    return units.reduce((h, u) => {
      let start = this.startOf(u);
      let end = this.next(u);
      let total = end.epoch - start.epoch;
      let n = this.epoch - start.epoch;
      h[u] = percent(n, total);
      return h
    }, {})
  };
  var progress$1 = progress;

  const now = function () {
    return this._from(null, this.tz)
  };

  let methods$1 = Object.assign({}, units$2, fmt, add, compare, { debug: debug$1, now, progress: progress$1 });

  // add-in our method aliases
  Object.keys(aliases$1).forEach(k => {
    methods$1[k] = methods$1[aliases$1[k]];
  });

  var api$1 = methods$1;

  // add method aliases
  // const aliases = [
  //   ['fmt', 'format'],
  //   ['text', 'format'],
  //   ['leapYear', 'isLeapYear'],
  //   ['isLeap', 'isLeapYear'],
  //   ['inDST', 'inDst'],
  //   ['hasDST', 'hasDst'],
  //   ['hours', 'hour'],
  //   ['minutes', 'minute'],
  //   ['seconds', 'second'],
  //   ['minus', 'subtract'],
  //   ['plus', 'add'],
  //   ['isDst', 'inDst'],
  //   // ['set', '_from'],
  // ]
  // aliases.forEach(a => {
  //   methods[a[0]] = methods[a[1]]
  // })

  lib$1.plugin({
    model,
    config: config$1,
    zones: zones$4,
    methods: methods$5,
    api: api$1
  });

  var api = {
    //luxon: keepCalendarTime,  keepLocalTime
    goto: function (tz, opts = {}) {
      // if (opts.keepClock === true) { }
      return this._from(this.epoch, tz)
    }
  };

  var goto = {
    api
  };

  var pckd = `Africa
	Abidjan,0,GMT
	Accra,0,GMT
	Addis_Ababa,3,EAT
	Algiers,1,CET|CEST
	Asmara,3,EAT
	Bamako,0,GMT
	Bangui,1,WAT
	Banjul,0,GMT
	Bissau,0,GMT
	Blantyre,2,CAT,s
	Brazzaville,1,WAT
	Bujumbura,2,CAT,s
	Cairo,2,EET|EEST
	Casablanca,0,WET|WEST,saha
	Ceuta,1,CET|CEST,eu2
	Conakry,0,GMT
	Dakar,0,GMT
	Dar_Es_Salaam,3,EAT
	Djibouti,3,EAT
	Douala,1,WAT
	El_Aaiun,0,WET|WEST,saha
	Freetown,0,GMT
	Gaborone,2,CAT,s
	Harare,2,CAT,s
	Johannesburg,2,SAST,s
	Juba,3,CAT
	Kampala,3,EAT
	Khartoum,2,CAT
	Kigali,2,CAT,s
	Kinshasa,1,WAT
	Lagos,1,WAT
	Libreville,1,WAT
	Lome,0,GMT
	Luanda,1,WAT
	Lubumbashi,2,CAT,s
	Lusaka,2,CAT,s
	Malabo,1,WAT
	Maputo,2,CAT,s
	Maseru,2,SAST,s
	Mbabane,2,SAST,s
	Mogadishu,3,EAT
	Monrovia,0,GMT
	Nairobi,3,EAT
	Ndjamena,1,WAT
	Niamey,1,WAT
	Nouakchott,0,GMT
	Ouagadougou,0,GMT
	Porto-novo,1,WAT
	Sao_Tome,0,GMT
	Tripoli,2,EET|EEST
	Tunis,1,CET|CEST
	Windhoek,1,CAT,s
America
	Adak,-10,HST|HDT,usa
	Anchorage,-9,AKST|AKDT,usa
	Anguilla,-4,AST|ADT
	Antigua,-4,AST|ADT
	Araguaina,-3,BRT
	Argentina,-3,ART,s
	Argentina/Buenos_Aires,-3,ART,s
	Argentina/Catamarca,-3,ART,s
	Argentina/Cordoba,-3,ART,s
	Argentina/La_Rioja,-3,ART,s
	Argentina/Mendoza,-3,ART,s
	Argentina/Rio_Gallegos,-3,ART,s
	Argentina/Salta,-3,ART,s
	Argentina/San_Juan,-3,ART,s
	Argentina/San_Luis,-3,ART,s
	Argentina/Tucuman,-3,ART,s
	Argentina/Ushuaia,-3,ART,s
	Aruba,-4,AST|ADT
	Asuncion,-4,PYT|PYST,par,s
	Atikokan,-5,EST|EDT
	Bahia,-3,BRT
	Bahia_Banderas,-6,CST|CDT,mex
	Barbados,-4,AST|ADT
	Belem,-3,BRT
	Belize,-6,CST|CDT
	Blanc-sablon,-4,AST|ADT
	Boa_Vista,-4,AMT
	Bogota,-5,COT
	Boise,-7,MST|MDT,usa
	Buenos_Aires,-3,ART,s
	Cambridge_Bay,-7,MST|MDT,usa
	Campo_Grande,-4,AMT,s
	Cancun,-5,EST|EDT
	Caracas,-4,VET
	Catamarca,-3,ART,s
	Cayenne,-3,GFT
	Cayman,-5,EST|EDT
	Chicago,-6,CST|CDT,usa
	Chihuahua,-7,HNPMX|HEPMX,mex
	Cordoba,-3,ART,s
	Costa_Rica,-6,CST|CDT
	Creston,-7,MST|MDT
	Cuiaba,-4,AMT,s
	Curacao,-4,AST|ADT
	Danmarkshavn,0,GMT
	Dawson,-7,MST|MDT
	Dawson_Creek,-7,MST|MDT
	Denver,-7,MST|MDT,usa
	Detroit,-5,EST|EDT,usa
	Dominica,-4,AST|ADT
	Edmonton,-7,MST|MDT,usa
	Eirunepe,-5,ACT
	El_Salvador,-6,CST|CDT
	Ensenada,-8,PST|PDT,usa
	Fort_Nelson,-7,MST|MDT
	Fort_wayne,-5,EST|EDT,usa
	Fortaleza,-3,BRT,s
	Glace_Bay,-4,AST|ADT,usa
	Godthab,-3,WGT|WGST,green
	Goose_Bay,-4,AST|ADT,usa
	Grand_Turk,-5,EST|EDT,usa
	Grenada,-4,AST|ADT
	Guadeloupe,-4,AST|ADT
	Guatemala,-6,CST|CDT
	Guayaquil,-5,ECT
	Guyana,-4,GYT
	Halifax,-4,AST|ADT,usa
	Havana,-5,HNCU|HECU,cuba
	Hermosillo,-7,HNPMX|HEPMX
	Indiana,-5,EST|EDT,usa
	Indiana/Indianapolis,-5,EST|EDT,usa
	Indiana/Knox,-6,CST|CDT,usa
	Indiana/Marengo,-5,EST|EDT,usa
	Indiana/Petersburg,-5,EST|EDT,usa
	Indiana/Tell_City,-6,CST|CDT,usa
	Indiana/Vevay,-5,EST|EDT,usa
	Indiana/Vincennes,-5,EST|EDT,usa
	Indiana/Winamac,-5,EST|EDT,usa
	Indianapolis,-5,EST|EDT,usa
	Inuvik,-7,MST|MDT,usa
	Iqaluit,-5,EST|EDT,usa
	Jamaica,-5,EST|EDT
	Jujuy,-3,ART,s
	Juneau,-9,AKST|AKDT,usa
	Kentucky,-5,EST|EDT,usa
	Kentucky/Louisville,-5,EST|EDT,usa
	Kentucky/Petersburg,-5,EST|EDT,usa
	Knox_in,-5,EST|EDT,usa
	Kralendijk,-4,AST|ADT
	La_Paz,-4,BOT,s
	Lima,-5,PET,s
	Los_Angeles,-8,PST|PDT,usa
	Louisville,-5,EST|EDT,usa
	Lower_Princes,-4,AST|ADT
	Maceio,-3,BRT
	Managua,-6,CST|CDT
	Manaus,-4,AMT,s
	Marigot,-4,AST|ADT
	Martinique,-4,AST|ADT
	Matamoros,-6,CST|CDT,usa
	Mazatlan,-7,HNPMX|HEPMX,mex
	Mendoza,-3,ART,s
	Menominee,-6,CST|CDT,usa
	Merida,-6,CST|CDT,mex
	Metlakatla,-9,AKST|AKDT,usa
	Mexico_City,-6,CST|CDT,mex
	Miquelon,-3,HNPM|HEPM,usa
	Moncton,-4,AST|ADT,usa
	Monterrey,-6,CST|CDT,mex
	Montevideo,-3,UYT,s
	Montreal,-5,EST|EDT,usa
	Montserrat,-4,AST|ADT
	Nassau,-5,EST|EDT,usa
	New_York,-5,EST|EDT,usa
	Nipigon,-5,EST|EDT,usa
	Nome,-9,AKST|AKDT,usa
	Noronha,-2,FNT
	North_Dakota/Beulah,-6,CST|CDT,usa
	North_Dakota/Center,-6,CST|CDT,usa
	North_Dakota/New_Salem,-6,CST|CDT,usa
	North_dakota,-7,MST|MDT,usa
	Nuuk,-3,WGT|WGST,green
	Ojinaga,-7,MST|MDT,usa
	Panama,-5,EST|EDT
	Pangnirtung,-5,EST|EDT,usa
	Paramaribo,-3,SRT
	Phoenix,-7,MST|MDT
	Port-au-prince,-5,EST|EDT,usa
	Port_Of_Spain,-4,AST|ADT
	Porto_Velho,-4,AMT
	Porto_acre,-5,ACT,s
	Puerto_Rico,-4,AST|ADT
	Punta_Arenas,-3,CLT|CLST,s
	Rainy_River,-6,CST|CDT,usa
	Rankin_Inlet,-6,CST|CDT,usa
	Recife,-3,BRT
	Regina,-6,CST|CDT
	Resolute,-6,CST|CDT,usa
	Rio_Branco,-5,ACT,s
	Rosario,-3,ART,s
	Santa_isabel,-8,PST|PDT,usa
	Santarem,-3,BRT
	Santiago,-4,CLT|CLST,chile,s
	Santo_Domingo,-4,AST|ADT
	Sao_Paulo,-3,BRT,s
	Scoresbysund,-1,HNEG|HEEG,eu0
	Shiprock,-7,MST|MDT,usa
	Sitka,-9,AKST|AKDT,usa
	St_Barthelemy,-4,AST|ADT
	St_Johns,-3.5,HNTN|HETN,usa
	St_Kitts,-4,AST|ADT
	St_Lucia,-4,AST|ADT
	St_Thomas,-4,AST|ADT
	St_Vincent,-4,AST|ADT
	Swift_Current,-6,CST|CDT
	Tegucigalpa,-6,CST|CDT
	Thule,-4,AST|ADT,usa
	Thunder_Bay,-5,EST|EDT,usa
	Tijuana,-8,PST|PDT,usa
	Toronto,-5,EST|EDT,usa
	Tortola,-4,AST|ADT
	Vancouver,-8,PST|PDT,usa
	Virgin,-4,AST|ADT
	Whitehorse,-7,MST|MDT
	Winnipeg,-6,CST|CDT,usa
	Yakutat,-9,AKST|AKDT,usa
	Yellowknife,-7,MST|MDT,usa
Antarctica
	Casey,8,CAST|CAST,ant,s
	Davis,7,DAVT,s
	Dumontdurville,10,PGT,s
	Macquarie,11,AEST|AEDT,aus,s
	Mawson,5,MAWT,s
	Mcmurdo,12,NZST|NZDT,nz,s
	Palmer,-3,ART,s
	Rothera,-3,ART,s
	South_pole,12,NZST|NZDT,nz,s
	Syowa,3,AST
	Troll,2,GMT,troll,s
	Vostok,6,MSK+4,s
Arctic
	Longyearbyen,1,CET|CEST,eu2
Asia
	Aden,3,AST
	Almaty,6,ALMT
	Amman,2,EET|EEST,jord
	Anadyr,12,ANAT
	Aqtau,5,ALMT
	Aqtobe,5,ALMT
	Ashgabat,5,TMT
	Ashkhabad,5,TMT
	Atyrau,5,ALMT
	Baghdad,3,AST
	Bahrain,3,AST
	Baku,4,AZT
	Bangkok,7,ICT
	Barnaul,7,KRAT
	Beirut,2,EET|EEST,leb
	Bishkek,6,KGT
	Brunei,8,BNT
	Calcutta,5.5,IST
	Chita,9,YAKT
	Choibalsan,8,ULAT
	Chongqing,8,CST
	Chungking,8,CST
	Colombo,5.5,IST
	Dacca,6,BST
	Damascus,2,EET|EEST,syr
	Dhaka,6,BST
	Dili,9,TLT,s
	Dubai,4,GST
	Dushanbe,5,TJT
	Famagusta,2,EET|EEST,eu3
	Gaza,2,EET|EEST,pal
	Harbin,8,CST
	Hebron,2,EET|EEST,pal
	Ho_Chi_Minh,7,ICT
	Hong_Kong,8,HKT
	Hovd,7,HOVT
	Irkutsk,8,IRKT
	Istanbul,3,TRT
	Jakarta,7,WIB,s
	Jayapura,9,WIT,s
	Jerusalem,2,IST|IDT,isr
	Kabul,4.5,AFT
	Kamchatka,12,PETT
	Karachi,5,PKT
	Kashgar,8,CST
	Kathmandu,5.75,NPT
	Katmandu,5.75,NPT
	Khandyga,9,YAKT
	Kolkata,5.5,IST
	Krasnoyarsk,7,KRAT
	Kuala_Lumpur,8,MYT,s
	Kuching,8,MYT
	Kuwait,3,AST
	Macao,8,CST
	Macau,8,CST
	Magadan,11,MAGT
	Makassar,8,WITA,s
	Manila,8,PHST
	Muscat,4,GST
	Nicosia,2,EET|EEST,eu3
	Novokuznetsk,7,KRAT
	Novosibirsk,7,NOVT
	Omsk,6,OMST
	Oral,5,ALMT
	Phnom_Penh,7,ICT
	Pontianak,7,WIB
	Pyongyang,9,KST
	Qatar,3,AST
	Qostanay,6,ALMT
	Qyzylorda,6,ALMT
	Rangoon,6.5,MMT
	Riyadh,3,AST
	Saigon,7,ICT
	Sakhalin,11,SAKT
	Samarkand,5,UZT
	Seoul,9,KST
	Shanghai,8,CST
	Singapore,8,SGT,s
	Srednekolymsk,12,SRET
	Taipei,8,CST
	Tashkent,5,UZT
	Tbilisi,4,GET
	Tehran,3.5,IRST|IRDT,iran
	Tel_aviv,2,IST|IDT,isr
	Thimbu,6,BT
	Thimphu,6,BT
	Tokyo,9,JST
	Tomsk,7,OMST
	Ujung_pandang,8,WITA,s
	Ulaanbaatar,8,ULAT
	Ulan_bator,8,ULAT
	Urumqi,8,CST
	Ust-nera,10,VLAT
	Vientiane,7,ICT
	Vladivostok,10,VLAT
	Yakutsk,10,YAKT
	Yangon,6.5,MMT
	Yekaterinburg,5,YEKT
	Yerevan,4,AMT
Atlantic
	Azores,-1,AZOT|AZOST,eu0
	Bermuda,-4,AST|ADT,usa
	Canary,0,WET|WEST,eu1
	Cape_Verde,-1,CVT
	Faeroe,0,WET|WEST,eu1
	Faroe,0,WET|WEST,eu1
	Jan_mayen,1,CET|CEST,eu2
	Madeira,0,WET|WEST,eu1
	Reykjavik,0,GMT
	South_Georgia,-2,GST
	St_Helena,0,GMT
	Stanley,-3,FKST,s
Australia
	Act,10,AEST|AEDT,aus,s
	Adelaide,9.5,ACST|ACDT,aus,s
	Brisbane,10,AEST,s
	Broken_Hill,9.5,ACST|ACDT,aus,s
	Canberra,10,AEST|AEDT,aus,s
	Currie,10,AEST|AEDT,aus,s
	Darwin,9.5,ACST,s
	Eucla,8.75,ACWST,s
	Hobart,10,AEST|AEDT,aus,s
	Lhi,10.5,LHST|LHDT,lhow,s
	Lindeman,10,AEST,s
	Lord_Howe,10.5,LHST|LHDT,lhow,s
	Melbourne,10,AEST|AEDT,aus,s
	North,9.5,ACST,s
	Nsw,10,AEST|AEDT,aus,s
	Perth,8,AWST,s
	Queensland,10,AEST,s
	South,9.5,ACST|ACDT,aus,s
	Sydney,10,AEST|AEDT,aus,s
	Tasmania,10,AEST|AEDT,aus,s
	Victoria,10,AEST|AEDT,aus,s
	West,8,AWST,s
	Yancowinna,9.5,ACST|ACDT,aus,s
Brazil
	Acre,-5,ACT,s
	Denoronha,-2,FNT
	East,-3,BRT,s
	West,-4,AMT,s
Canada
	Atlantic,-4,AST|ADT,usa
	Central,-6,CST|CDT,usa
	East-saskatchewan,-6,CST|CDT
	Eastern,-5,EST|EDT,usa
	Mountain,-7,MST|MDT,usa
	Newfoundland,-3.5,HNTN|HETN,usa
	Pacific,-8,PST|PDT,usa
	Saskatchewan,-6,CST|CDT
	Yukon,-7,MST|MDT
Chile
	Continental,-4,CLT|CLST,chile,s
	Easterisland,-6,EAST|EASST,east,s
Cuba
	,-5,HNCU|HECU,cuba
Egypt
	,2,EET|EEST
Eire
	,0,GMT|IST,eu1
Etc
	GMT,0,GMT
	Greenwich,0,GMT
	Uct,0,UTC
	Universal,0,UTC
	Unknown,0,UTC
	Utc,0,UTC
	Zulu,0,UTC
Europe
	Amsterdam,1,CET|CEST,eu2
	Andorra,1,CET|CEST,eu2
	Astrakhan,4,MSK
	Athens,2,EET|EEST,eu3
	Belfast,0,GMT|BST,eu1
	Belgrade,1,CET|CEST,eu2
	Berlin,1,CET|CEST,eu2
	Bratislava,1,CET|CEST,eu2
	Brussels,1,CET|CEST,eu2
	Bucharest,2,EET|EEST,eu3
	Budapest,1,CET|CEST,eu2
	Busingen,1,CET|CEST,eu2
	Chisinau,2,EET|EEST,eu2
	Copenhagen,1,CET|CEST,eu2
	Dublin,0,GMT|IST,eu1
	Gibraltar,1,CET|CEST,eu2
	Guernsey,0,GMT|BST,eu1
	Helsinki,2,EET|EEST,eu3
	Isle_Of_Man,0,GMT|BST,eu1
	Istanbul,3,TRT
	Jersey,0,GMT|BST,eu1
	Kaliningrad,2,EET|EEST
	Kiev,2,EET|EEST,eu3
	Kirov,3,MSK
	Kyiv,2,EET|EEST,eu3
	Lisbon,0,WET|WEST,eu1
	Ljubljana,1,CET|CEST,eu2
	London,0,GMT|BST,eu1
	Luxembourg,1,CET|CEST,eu2
	Madrid,1,CET|CEST,eu2
	Malta,1,CET|CEST,eu2
	Mariehamn,2,EET|EEST,eu3
	Minsk,3,MSK
	Monaco,1,CET|CEST,eu2
	Moscow,3,MSK
	Nicosia,2,EET|EEST,eu3
	Oslo,1,CET|CEST,eu2
	Paris,1,CET|CEST,eu2
	Podgorica,1,CET|CEST,eu2
	Prague,1,CET|CEST,eu2
	Riga,2,EET|EEST,eu3
	Rome,1,CET|CEST,eu2
	Samara,4,SAMT
	San_Marino,1,CET|CEST,eu2
	Sarajevo,1,CET|CEST,eu2
	Saratov,4,SAMT
	Simferopol,2,EET|EEST,eu3
	Skopje,1,CET|CEST,eu2
	Sofia,2,EET|EEST,eu3
	Stockholm,1,CET|CEST,eu2
	Tallinn,2,EET|EEST,eu3
	Tirane,1,CET|CEST,eu2
	Tiraspol,2,EET|EEST,eu2
	Ulyanovsk,4,MSK
	Uzhgorod,2,EET|EEST,eu3
	Vaduz,1,CET|CEST,eu2
	Vatican,1,CET|CEST,eu2
	Vienna,1,CET|CEST,eu2
	Vilnius,2,EET|EEST,eu3
	Volgograd,4,MSK
	Warsaw,1,CET|CEST,eu2
	Zagreb,1,CET|CEST,eu2
	Zaporozhye,2,EET|EEST,eu3
	Zurich,1,CET|CEST,eu2
GB
	,0,GMT|BST,eu1
Gb-eire
	,0,GMT|BST,eu1
Gmt+0
	,0,GMT
Gmt-0
	,0,GMT
Gmt0
	,0,GMT
Greenwich
	,0,GMT
Hongkong
	,8,HKT
Iceland
	,0,GMT
Indian
	Antananarivo,3,EAT
	Chagos,6,IOT
	Christmas,7,CXT,s
	Cocos,6.5,CCT
	Comoro,3,EAT
	Kerguelen,5,TFT,s
	Mahe,4,SCT
	Maldives,5,MVT
	Mauritius,4,MUT
	Mayotte,3,EAT
	Reunion,4,RET,s
Iran
	,3.5,IRST|IRDT,iran
Israel
	,2,IST|IDT,isr
Jamaica
	,-5,EST|EDT
Japan
	,9,JST
Kwajalein
	,12,MHT
Libya
	,2,EET|EEST
Mexico
	Bajanorte,-8,PST|PDT,usa
	Bajasur,-7,HNPMX|HEPMX,mex
	General,-6,CST|CDT,mex
Navajo
	,-7,MST|MDT,usa
Nz
	,12,NZST|NZDT,nz,s
Nz-chat
	,12.75,CHAST|CHADT,chat,s
Pacific
	Apia,13,WST|WST,s
	Auckland,12,NZST|NZDT,nz,s
	Bougainville,11,PGT,s
	Chatham,12.75,CHAST|CHADT,chat,s
	Chuuk,10,CHUT
	Easter,-6,EAST|EASST,east,s
	Efate,11,VUT
	Fakaofo,13,TKT
	Fiji,12,FJT|FJT,fiji,s
	Funafuti,12,TVT
	Galapagos,-6,COT
	Gambier,-9,GAMT
	Guadalcanal,11,SBT
	Guam,10,ChST
	Honolulu,-10,HAST|HADT
	Johnston,-10,HAST|HADT
	Kanton,13,PHOT
	Kiritimati,14,LINT
	Kosrae,11,KOST
	Kwajalein,12,MHT
	Majuro,12,MHT
	Marquesas,-9.5,MART
	Midway,-11,SST
	Nauru,12,NRT
	Niue,-11,NUT
	Norfolk,10.5,NFT|NFDT,aus
	Noumea,11,NCT
	Pago_Pago,-11,SST
	Palau,9,PWT
	Pitcairn,-8,PST
	Pohnpei,11,PONT
	Ponape,11,PONT
	Port_Moresby,10,PGT,s
	Rarotonga,-10,CKT
	Saipan,10,ChST
	Samoa,-11,SST
	Tahiti,-10,TAHT
	Tarawa,12,GILT
	Tongatapu,13,TOT,s
	Truk,10,CHUT
	Wake,12,WAKT
	Wallis,12,WFT
	Yap,10,CHUT
Poland
	,1,CET|CEST,eu2
Portugal
	,0,WET|WEST,eu1
Prc
	,8,CST
Roc
	,8,CST
Rok
	,9,KST
Singapore
	,8,SGT,s
Turkey
	,3,TRT
UTC
	,0,UTC
	Unknown,0,UTC
Uct
	,0,UTC
Universal
	,0,UTC
Us
	Alaska,-9,AKST|AKDT,usa
	Aleutian,-10,HST|HDT,usa
	Arizona,-7,MST|MDT
	Central,-6,CST|CDT,usa
	East-indiana,-5,EST|EDT,usa
	Eastern,-5,EST|EDT,usa
	Hawaii,-10,HAST|HADT
	Indiana-starke,-5,EST|EDT,usa
	Michigan,-5,EST|EDT,usa
	Mountain,-7,MST|MDT,usa
	Pacific,-8,PST|PDT,usa
	Pacific-new,-8,PST|PDT,usa
	Samoa,-11,SST
W-su
	,3,MSK
Zulu
	,0,UTC
america
	argentina/buenos_aires,-3,ART,s
	argentina/catamarca,-3,ART,s
	argentina/comodrivadavia,-3,ART,s
	argentina/cordoba,-3,ART,s
	argentina/jujuy,-3,ART,s
	argentina/mendoza,-3,ART,s
	argentina/rosario,-3,ART,s
`;

  let zones$1 = {};
  let area = null;
  // unpack compressed iana file
  pckd.split('\n').forEach(line => {
    if (!/^\t/.test(line)) {
      area = line.trim();
      return
    }
    let [name, offset, shrt, dst, hem] = line.split(/,/);
    let iana = `${area}/${name.trim()}`;
    shrt = shrt.split(/\|/);
    offset = Number(offset);
    zones$1[iana] = { offset, shrt };
    if (dst) {
      zones$1[iana].dst = dst;
    }
    zones$1[iana].hem = hem ? hem : 'n';
  });

  //add etc/gmt+n
  for (let i = -14; i <= 14; i += 0.5) {
    let num = i;
    if (num > 0) {
      num = '+' + num;
    }
    // Etc/GMT-5
    let name = 'Etc/GMT' + num;
    zones$1[name] = {
      offset: i * -1, //they're negative!
      hem: 'n' //(sorry)
    };
    let alias = 'UTC/GMT' + num; //this one too, why not.
    zones$1[alias] = zones$1[name];
  }
  // this appear sometimes
  zones$1['Etc/GMT+0'] = zones$1['Etc/GMT'];
  zones$1['Etc/GMT-0'] = zones$1['Etc/GMT'];
  // add aliases
  // Object.keys(aliases).forEach(k => {
  //   zones[k] = zones[aliases[k]]
  //   if (!zones[k]) {
  //     console.log(k)
  //   }
  // })
  var zones$2 = zones$1;

  var config = {

    // <15% of the world lives in the Southern Hemisphere
    fallbackHemisphere: 'n',
  };

  //find the implicit iana code for this machine.
  //safely query the Intl object
  //based on - https://bitbucket.org/pellepim/jstimezonedetect/src

  //this Intl object is not supported often, yet
  const safeIntl = () => {
    if (typeof Intl === 'undefined' || typeof Intl.DateTimeFormat === 'undefined') {
      return null
    }
    let format = Intl.DateTimeFormat();
    if (typeof format === 'undefined' || typeof format.resolvedOptions === 'undefined') {
      return null
    }
    let timezone = format.resolvedOptions().timeZone;
    if (!timezone) {
      return null
    }
    return timezone
  };

  //do it once per computer
  const tzOfComputer = safeIntl();

  const fallbackTz = function (world) {
    // deduce computer timezone?
    if (world.config.tryLocalTimezone) {

      // use our Intl version, if found
      if (tzOfComputer && tzOfComputer !== 'Etc/Unknown') {
        return tzOfComputer
      }
      // try the sloppier version
      const mins = new Date().getTimezoneOffset();// get (current) timezone offset from js Date
      let h = mins / 60;
      let name = `Etc/GMT${h * -1}`;
      if (world.zones.hasOwnProperty(name)) {
        return name
      }
    }
    return world.config.fallbackTz || null
  };
  var fallbackTz$1 = fallbackTz;

  const findTz = function (str, world) {
    str = str || '';
    if (world.zones.hasOwnProperty(str)) {
      return str
    }
    str = str.toLowerCase().trim();
    // if (aliases.hasOwnProperty(str)) {
    //   return aliases[str]
    // }
    // if (mapping.hasOwnProperty(str)) {
    //   return mapping[str]
    // }
    return null
  };
  var parseTz = findTz;

  var methods = { fallbackTz: fallbackTz$1, parseTz };

  var zones = {
    zones: zones$2,
    config,
    methods
  };

  lib$1.plugin(goto);
  lib$1.plugin(zones);

  return lib$1;

}));
